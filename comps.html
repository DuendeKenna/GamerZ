<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Administrador de Vectores de Productos</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ctext y='26' font-size='28' x='3' font-family='Arial'%3E%24%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,400;0,700;1,400&family=Saira:wght@400;900;1,400&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* General Styles */
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            /* bg-gray-900 */
            color: #e5e7eb;
            /* text-gray-200 */
        }

        .font-saira-black {
            font-family: 'Saira', sans-serif;
            font-weight: 900;
        }

        /* Input and Textarea Styles */
        .overview-table input,
        .overview-table textarea {
            background: rgba(31, 41, 55, 0.5) !important;
            /* bg-gray-800/50 */
            font-family: 'Saira', sans-serif;
            font-weight: 600;
            box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.10);
            color: #e5e7eb;
            border-radius: 0.375rem;
            border: 1px solid #374151;
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .overview-table input:focus,
        .overview-table textarea:focus {
            border-color: #6366f1;
            /* indigo-500 */
            box-shadow: 0 0 0 2px #6366f1;
        }

        /* Shared input style for tables and base details */
        .overview-table input[type="text"],
        .overview-table input[type="number"],
        .overview-table textarea,
        #base-details input,
        #base-details textarea,
        #base-details select {
            background-color: #1f2937;
            /* bg-gray-800 */
            border: 1px solid #374151;
            /* border-gray-700 */
            border-radius: 0.375rem;
            padding: 0.5rem;
            font-size: 0.875rem;
            color: #e5e7eb;
            transition: all 0.15s ease-in-out;
            width: 100%;
        }

        .overview-table input[type="text"]:focus,
        .overview-table input[type="number"]:focus,
        .overview-table textarea:focus,
        #base-details input:focus,
        #base-details textarea:focus,
        #base-details select:focus {
            border-color: #6366f1;
            /* indigo-500 */
            box-shadow: 0 0 0 2px #4f46e5;
        }

        .overview-table textarea {
            min-height: 40px;
        }


        /* Button Styles */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, opacity 0.2s;
            cursor: pointer;
        }

        .btn-primary {
            background-color: #6366f1;
            color: #ffffff;
        }

        .btn-primary:hover {
            background-color: #4f46e5;
        }

        .btn-secondary {
            background-color: #4b5563;
            color: #ffffff;
            padding: 0.5rem 1rem;
        }

        .btn-secondary:hover {
            background-color: #374151;
        }

        .btn-danger {
            background-color: #ef4444;
            color: #ffffff;
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        .btn-success {
            background-color: #22c55e;
            color: #ffffff;
        }

        .btn-success:hover {
            background-color: #16a34a;
        }

        .btn-info {
            background-color: #3b82f6;
            color: #ffffff;
        }

        .btn-info:hover {
            background-color: #2563eb;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Icon and Title Styles */
        .lucide-icon {
            display: inline-block;
            vertical-align: middle;
            width: 1em;
            height: 1em;
            stroke-width: 2;
            stroke: currentColor;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .section-title-admin {
            border-bottom: 3px solid;
            border-image: linear-gradient(to right, #6366f1, #a855f7) 1;
            padding-bottom: 0.5rem;
            display: inline-block;
        }

        /* Output and Message Styles */
        #output-code {
            background-color: #1f2937;
            /* bg-gray-800 */
            border-color: #374151;
            /* border-gray-700 */
            color: #42d232;
            /* green-400 */
        }

        /* Table Styles */
        .overview-table th,
        .overview-table td {
            padding: 0.5rem;
            vertical-align: middle;
        }

        .add-row-button-cell {
            text-align: center;
            padding-top: 1rem;
            padding-bottom: 1rem;
        }

        .add-row-button {
            background-color: #6366f1;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .add-row-button:hover {
            background-color: #4f46e5;
        }

        /* Image Preview Styles */
        #image-preview {
            max-width: 250px;
            max-height: 250px;
            transition: opacity 0.2s ease-in-out;
        }

        #image-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Category Navigation Bar Styles */
        .category-navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            z-index: 50;
            background: linear-gradient(to right, #1f2937 80%, #6366f1 100%);
            border-bottom: 2px solid #6366f1;
            box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.25);
            padding: 0.5rem 1rem;
            transition: top 0.2s;
        }

        .category-navbar .cat-nav-btn {
            background: none;
            border: none;
            color: #e5e7eb;
            font-weight: 600;
            font-size: 0.9rem;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            transition: background 0.15s, color 0.15s;
            cursor: pointer;
            white-space: nowrap;
            position: relative;
        }

        .category-navbar .cat-nav-btn:not(:last-child)::after {
            content: '|';
            position: absolute;
            right: -0.25rem;
            top: 50%;
            transform: translateY(-50%);
            color: #4b5563;
        }

        .category-navbar .cat-nav-btn.active,
        .category-navbar .cat-nav-btn:hover {
            background: #6366f1;
            color: #fff;
        }

        .category-navbar-spacer {
            width: 100%;
            transition: height 0.2s;
        }

        /* Bases & Bundles Section Styles */
        .management-section {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 1.5rem;
        }

        .list-item {
            cursor: pointer;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
            border: 1px solid #374151;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            min-height: 64px;
        }

        .list-item.active {
            background-color: #6366f1;
            color: white;
            border-color: #4f46e5;
        }

        .list-item:not(.active):hover {
            background-color: #374151;
        }

        /* Accordion Styles */
        .accordion-header .lucide-icon {
            transition: transform 0.3s ease-in-out;
        }

        .accordion-header .rotate-180 {
            transform: rotate(180deg);
        }

        .accordion-content {
            transition: max-height 0.3s ease-in-out;
            overflow: hidden;
        }

        .ram-qty-btn {
            background-color: #374151;
            border: 1px solid #4b5563;
        }

        .ram-qty-btn.active {
            background-color: #6366f1;
            border-color: #4f46e5;
            color: white;
        }

        /* Popups Styles */
        #price-check-popup,
        #price-chart-popup,
        #filter-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        #price-check-popup.hidden,
        #price-chart-popup.hidden,
        #filter-popup.hidden {
            display: none;
        }

        .popup-content {
            background-color: #1f2937;
            /* bg-gray-800 */
            border: 1px solid #4b5563;
            /* border-gray-600 */
            border-radius: 0.75rem;
            /* rounded-xl */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .popup-content-chart {
            background-color: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background-color: #111827;
            /* bg-gray-900 */
            border-bottom: 1px solid #374151;
            /* border-gray-700 */
        }

        .popup-body {
            padding: 1.5rem;
        }

        .popup-body-chart {
            padding: 1.5rem;
            height: 400px;
            /* Fixed height for the chart */
        }

        .popup-body input {
            background-color: #374151;
            border: 1px solid #4b5563;
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: right;
        }

        .popup-body input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 2px #4f46e5;
        }

        /* Filter Popup Specific Styles */
        #filter-popup .popup-content {
            max-width: 500px;
        }

        .filter-checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
        }

        .filter-checkbox-label:hover {
            background-color: #374151;
        }

        .filter-checkbox-label input {
            margin-right: 0.75rem;
            width: 1.15rem;
            height: 1.15rem;
        }

        .color-swatch {
            width: 1rem;
            height: 1rem;
            border-radius: 0.25rem;
            margin-right: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Tooltip Styles */
        .price-wrapper {
            position: relative;
        }

        .price-history-tooltip {
            visibility: hidden;
            width: 220px;
            background-color: #111827;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #374151;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .price-wrapper:hover .price-history-tooltip {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-table {
            width: 100%;
            font-size: 0.8rem;
        }

        .tooltip-table th,
        .tooltip-table td {
            padding: 4px 8px;
            text-align: left;
        }

        .tooltip-table th {
            border-bottom: 1px solid #374151;
        }

        .tooltip-table tr:nth-child(even) {
            background-color: #1f2937;
        }

        /* Previous price indicator styles */
        .previous-price-indicator {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            margin-bottom: 4px;
            z-index: 5;
            display: flex;
            gap: 4px;
        }

        .old-price-span,
        .diff-span {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
        }

        /* NEW: Link Manager Styles */
        .link-manager-container {
            position: absolute;
            width: 250px;
            background-color: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            bottom: 100%;
            right: 0;
            margin-bottom: 8px;
        }


        @media (max-width: 1024px) {
            .management-section {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 639px) {
            .mobile-hidden-if-not-visible {
                display: none;
            }
        }
    </style>
</head>

<body class="p-4 md:p-8 bg-gray-900 min-h-screen text-gray-200">
    <!-- RESTORED: Image preview element -->
    <div id="image-preview"
        class="hidden fixed bottom-4 right-4 bg-gray-800 border border-gray-700 rounded-lg shadow-lg z-50 p-2">
        <img src="" alt="Vista Previa" class="max-w-xs max-h-xs object-contain">
    </div>

    <!-- Sticky category navigation bar -->
    <div id="category-navbar" class="category-navbar hidden sm:flex"></div>
    <div id="category-navbar-spacer" class="category-navbar-spacer hidden sm:block"></div>

    <!-- Main container -->
    <div class="mx-auto bg-gray-800 p-6 md:p-8 rounded-xl shadow-lg border border-gray-700"
        style="width:95%;max-width:1800px;">
        <h1 class="text-3xl font-saira-black text-white mb-6 text-center">Administrador de Vectores de Productos</h1>

        <div id="top-actions" class="hidden md:flex justify-center items-center gap-4 mb-8 flex-wrap">
            <button onclick="reloadDataFromJson()" class="btn btn-secondary">
                <span class="lucide-icon mr-2" data-lucide="refresh-ccw"></span> Recargar de Archivo
            </button>
            <button onclick="resetSessionAndReload()" class="btn btn-secondary border-amber-500/50 hover:bg-amber-600">
                <span class="lucide-icon mr-2" data-lucide="eraser"></span> Restablecer Sesión
            </button>
            <button id="price-check-loop-btn" onclick="togglePriceCheckLoop()" class="btn btn-success">
                <span class="lucide-icon mr-2" data-lucide="play-circle"></span>
                <span id="price-check-loop-btn-text">Chequeo en Lote</span>
            </button>
            <span id="price-check-queue-count" class="ml-2 font-semibold text-gray-200">0</span>
        </div>

        <div id="bases-section-container"
            class="mb-8 bg-gray-900 rounded-lg shadow-sm border border-gray-700 hidden md:block">
            <h3 id="bases-accordion-header"
                class="accordion-header flex justify-between items-center text-xl font-semibold text-gray-100 p-6 cursor-pointer">
                <span>Bases (CPU + Mother + RAM)</span>
                <span class="lucide-icon" data-lucide="chevron-down"></span>
            </h3>
            <div id="bases-accordion-content" class="accordion-content p-6 pt-0 hidden">
                <div id="bases-section" class="management-section">
                    <!-- Content generated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Bundles Section (new) -->
        <div id="bundles-section-container"
            class="mb-8 bg-gray-900 rounded-lg shadow-sm border border-gray-700 hidden md:block">
            <h3 id="bundles-accordion-header"
                class="accordion-header flex justify-between items-center text-xl font-semibold text-gray-100 p-6 cursor-pointer">
                <span>Bundles (Conjuntos de Componentes)</span>
                <span class="lucide-icon" data-lucide="chevron-down"></span>
            </h3>
            <div id="bundles-accordion-content" class="accordion-content p-6 pt-0 hidden">
                <div id="bundles-section" class="management-section">
                    <!-- Left: list of bundles; Right: selected bundle details -->
                    <div id="bundles-list" class="space-y-3">
                        <!-- Generated by JS -->
                    </div>
                    <div id="bundle-details" class="bg-gray-800 p-4 rounded-lg border border-gray-700">
                        <!-- Generated by JS -->
                    </div>
                </div>
            </div>
        </div>


        <!-- Table View Container -->
        <div id="overview-view" class="tab-content">
            <!-- Content will be generated by JavaScript -->
        </div>

        <section class="mt-10 p-6 bg-gray-900 rounded-lg shadow-inner border border-gray-700 hidden md:block">
            <h2 class="text-2xl font-semibold text-gray-100 mb-4 text-center section-title-admin">Generar Archivos de
                Actualización</h2>
            <textarea id="output-code" rows="15"
                class="w-full p-4 border border-gray-700 rounded-lg bg-gray-800 text-green-400 font-mono text-sm resize-y"
                readonly></textarea>
            <div class="flex flex-wrap justify-center items-center mt-4 gap-4">
                <button onclick="generateCode()" class="btn btn-primary">
                    <span class="lucide-icon mr-2" data-lucide="code"></span> Generar Actualización
                </button>
                <button onclick="copyCode()" class="btn btn-secondary">
                    <span class="lucide-icon mr-2" data-lucide="copy"></span> Copiar Actualización
                </button>
                <button onclick="generateHistoryCode()" class="btn btn-info">
                    <span class="lucide-icon mr-2" data-lucide="history"></span> Generar Historial
                </button>
                <button onclick="copyHistoryCode()" class="btn btn-secondary">
                    <span class="lucide-icon mr-2" data-lucide="copy-check"></span> Copiar Historial
                </button>
            </div>
            <div id="message-container"
                class="fixed bottom-6 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2 z-50"></div>
        </section>
    </div>

    <!-- Price Check Popup -->
    <div id="price-check-popup" class="hidden">
        <div class="popup-content">
            <div class="popup-header">
                <h3 id="popup-title" class="text-lg font-bold text-white">Chequeo de Precio</h3>
                <button onclick="closePriceCheckPopup()" class="text-gray-400 hover:text-white">
                    <span class="lucide-icon w-6 h-6" data-lucide="x"></span>
                </button>
            </div>
            <div class="popup-body">
                <p class="text-center text-gray-300 mb-4">La página del producto se abrió en una nueva pestaña. Por
                    favor, ingrese el nuevo precio a continuación.</p>
                <div class="flex justify-between items-center bg-gray-900 p-4 rounded-lg">
                    <div>
                        <p class="text-sm text-gray-400">Precio Actual</p>
                        <p id="popup-current-price" class="text-2xl font-bold text-teal-400">$0</p>
                    </div>
                    <div class="flex flex-col items-end">
                        <label for="popup-new-price" class="text-sm text-gray-400 mb-1">Nuevo Precio (Enter)</label>
                        <input type="text" id="popup-new-price" placeholder="Ingresar..."
                            oninput="formatPriceInput(this)" onkeydown="handleManualPriceCheck(event)"
                            onpaste="handlePastePrice(event)" class="w-40">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Price Chart Popup -->
    <div id="price-chart-popup" class="hidden" onclick="if (event.target === this) closePriceChartPopup()">
        <div class="popup-content-chart">
            <div class="popup-header">
                <h3 id="chart-popup-title" class="text-lg font-bold text-white">Historial de Precios</h3>
                <button id="toggle-chart-type-btn" onclick="toggleChartType()"
                    class="ml-3 text-gray-300 hover:text-white" title="Cambiar vista (columnas/lineas)">
                    <span class="lucide-icon w-6 h-6" data-lucide="bar-chart"></span>
                </button>
                <div id="price-chart-legend" class="ml-4 flex items-center gap-3 text-sm text-gray-300"
                    style="margin-left:12px;">
                    <span class="flex items-center gap-2"><span
                            style="width:12px;height:12px;background:rgba(139,92,246,0.95);display:inline-block;border-radius:2px;border:1px solid rgba(139,92,246,1);"></span>
                        Subió</span>
                    <span class="flex items-center gap-2"><span
                            style="width:12px;height:12px;background:rgba(34,197,94,0.95);display:inline-block;border-radius:2px;border:1px solid rgba(34,197,94,1);"></span>
                        Bajó</span>
                    <span class="flex items-center gap-2"><span
                            style="width:12px;height:12px;background:rgba(2,132,199,0.95);display:inline-block;border-radius:2px;border:1px solid rgba(2,132,199,1);"></span>
                        Mantuvo</span>
                </div>
            </div>
            <div class="popup-body-chart">
                <canvas id="price-chart-canvas"></canvas>
            </div>
        </div>
    </div>

    <!-- NEW: Filter FAB -->
    <div id="filter-fab" class="fixed bottom-6 left-6 z-40">
        <button onclick="openFilterPopup()"
            class="w-14 h-14 bg-indigo-600 text-white rounded-full flex items-center justify-center shadow-lg hover:bg-indigo-700 transition-transform hover:scale-110">
            <span class="lucide-icon w-7 h-7" data-lucide="filter"></span>
        </button>
    </div>

    <!-- NEW: Filter Popup -->
    <div id="filter-popup" class="hidden">
        <div class="popup-content">
            <div class="popup-header">
                <h3 class="text-lg font-bold text-white">Filtros de Visualización</h3>
                <button onclick="closeFilterPopup()" class="text-gray-400 hover:text-white">
                    <span class="lucide-icon w-6 h-6" data-lucide="x"></span>
                </button>
            </div>
            <div class="popup-body space-y-6">
                <div>
                    <h4 class="font-semibold text-gray-200 mb-2">Colorear por Cambio de Precio</h4>
                    <p class="text-sm text-gray-400 mb-3">Compara el precio actual con el anterior en el historial para
                        todas las filas.</p>
                    <button onclick="colorAllRowsByPriceChange()" class="btn btn-primary w-full">
                        <span class="lucide-icon mr-2" data-lucide="paintbrush-2"></span>
                        Aplicar Coloreo a Todo
                    </button>
                </div>
                <div>
                    <h4 class="font-semibold text-gray-200 mb-2">Mostrar Filas por Color</h4>
                    <div id="color-filter-options" class="space-y-2">
                        <!-- Checkboxes will be generated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Gemini AI Analysis Popup -->
    <div id="gemini-analysis-popup" class="hidden">
        <div class="popup-content" style="max-width: 600px;">
            <div class="popup-header">
                <h3 class="text-lg font-bold text-white flex items-center gap-2">
                    <span class="text-purple-400">✨</span> Análisis de la Base con IA
                </h3>
                <button onclick="closeGeminiPopup()" class="text-gray-400 hover:text-white">
                    <span class="lucide-icon w-6 h-6" data-lucide="x"></span>
                </button>
            </div>
            <div id="gemini-popup-body" class="popup-body">
                <div id="gemini-loading" class="text-center py-8 hidden">
                    <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-purple-400"></div>
                    <p class="mt-4 text-gray-300">Analizando configuración y buscando recomendaciones...</p>
                </div>
                <div id="gemini-result" class="text-gray-300 space-y-4 max-w-none">
                    <!-- Content will be injected here -->
                </div>
            </div>
        </div>
    </div>


    <script>
        // --- Data Configuration ---
        const CATEGORY_NAV_LIST = [
            { key: 'bases-section-container', label: 'Bases' },
            { key: 'bundles-section-container', label: 'Bundles' },
            { key: 'armadasOptions', label: 'Armadas' },
            { key: 'miniPcOptions', label: 'MiniPCs' },
            { key: 'towersOptions', label: 'Torres' },
            { key: 'comboOptions', label: 'Combos' },
            { key: 'cpuOptions', label: 'CPU' },
            { key: 'motherboardOptions', label: 'Mother' },
            { key: 'ramOptions', label: 'RAM' },
            { key: 'gpuOptions', label: 'GPU' },
            { key: 'ssdOptions', label: 'SSD' },
            { key: 'psuOptions', label: 'PSU' },
            { key: 'monitorOptions', label: 'Monitores' },
            { key: 'mouseOptions', label: 'Mouse' },
            { key: 'joystickOptions', label: 'Joysticks' },
            { key: 'keyboardOptions', label: 'Teclados' },
            { key: 'comboMouseTecladoOptions', label: 'M+T' },
            { key: 'auricularesOptions', label: 'Auris' },
            { key: 'parlantesOptions', label: 'Parlantes' },
            { key: 'webcamOptions', label: 'Webcams' },
            { key: 'microfonosOptions', label: 'Mics' },
            { key: 'wifiOptions', label: 'WiFi' },
            { key: 'arosDeLuzOptions', label: 'Luz' }
        ];

        const dataMap = {
            baseOptions: [],
            bundlesOptions: [],
            armadasOptions: [], towersOptions: [], ssdOptions: [], gpuOptions: [],
            psuOptions: [], motherboardOptions: [], cpuOptions: [], ramOptions: [], comboOptions: [],
            monitorOptions: [], mouseOptions: [], joystickOptions: [], keyboardOptions: [],
            comboMouseTecladoOptions: [], auricularesOptions: [], parlantesOptions: [],
            webcamOptions: [], microfonosOptions: [], wifiOptions: [], arosDeLuzOptions: [],
            miniPcOptions: []
        };

        let selectedBaseIndex = 0;

        // Price Check Loop State
        // priceCheckQueue will store entries as { categoryKey, productId }
        let priceCheckQueue = [];
        let currentQueueIndex = 0;
        let isLoopRunning = false;
        // Timeout handle for delayed link opening when showing price-check popup
        let priceCheckOpenTimeout = null;

        let priceChartInstance = null;
        let openLinkManagerId = null;

        // NEW: Filter State
        let filterState = {
            increased: true,
            decreased: true,
            same: true,
            default: true
        };

        // --- Gemini API Functions ---
        async function callGeminiAPI(prompt) {
            const apiKey = ""; // Provided by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
            };

            let response;
            let attempts = 0;
            const maxAttempts = 5;
            let delay = 1000;

            while (attempts < maxAttempts) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (text) {
                            return text;
                        } else {
                            throw new Error('Empty or unexpected API response format.');
                        }
                    } else if (response.status === 429 || response.status >= 500) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2;
                        attempts++;
                    } else {
                        const errorResult = await response.json();
                        throw new Error(`API Error: ${errorResult.error?.message || response.statusText}`);
                    }
                } catch (error) {
                    if (attempts >= maxAttempts - 1) {
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                    attempts++;
                }
            }
            throw new Error('Could not get a response from the API after several attempts.');
        }

        function openGeminiPopup() {
            document.getElementById('gemini-analysis-popup').classList.remove('hidden');
        }

        function closeGeminiPopup() {
            document.getElementById('gemini-analysis-popup').classList.add('hidden');
        }

        async function analyzeSelectedBase() {
            const base = dataMap.baseOptions[selectedBaseIndex];
            if (!base) return;

            const cpu = dataMap.cpuOptions.find(c => c.id == base.cpu);
            const mother = dataMap.motherboardOptions.find(m => m.id == base.mother);
            const ram = dataMap.ramOptions.find(r => r.id == base.ram);

            if (!cpu || !mother || !ram) {
                showToast('Por favor, seleccione CPU, Mother y RAM para la base.', 'error');
                return;
            }

            openGeminiPopup();
            const loadingDiv = document.getElementById('gemini-loading');
            const resultDiv = document.getElementById('gemini-result');
            loadingDiv.classList.remove('hidden');
            resultDiv.classList.add('hidden');
            resultDiv.innerHTML = '';

            const prompt = `Actúa como un experto en armado de PCs para el mercado argentino. Analiza esta "base" de componentes: CPU: "${cpu.name}", Motherboard: "${mother.name}", RAM: "${ram.name}" (Cantidad: ${base.cantRam}).\n\nResponde en el siguiente formato:\n\n**Análisis de la Base:**\n[Describe en 2-3 frases para qué tipo de usuario y uso es ideal esta configuración (ej: gaming 1080p, edición de video, etc.) y cuáles son sus puntos fuertes.]\n\n**Recomendación de GPU:**\n[Recomienda UNA GPU específica que haga un buen equilibrio con esta base, explicando en una frase por qué es una buena elección.]\n\n**Recomendación de Fuente (PSU):**\n[Recomienda UNA potencia y certificación de fuente (ej: 650W 80+ Bronze) explicando en una frase por qué es adecuada.]`;

            try {
                const responseText = await callGeminiAPI(prompt);
                let formattedHtml = responseText
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\n/g, '<br>');
                resultDiv.innerHTML = formattedHtml;
            } catch (error) {
                console.error('Error analyzing base:', error);
                resultDiv.innerHTML = `<p class="text-red-400">Hubo un error al contactar a la IA. Por favor, intente de nuevo. Error: ${error.message}</p>`;
                showToast('Error al analizar la base.', 'error');
            } finally {
                loadingDiv.classList.add('hidden');
                resultDiv.classList.remove('hidden');
            }
        }

        async function generateDescription(categoryKey, index, buttonElement) {
            const product = dataMap[categoryKey][index];
            if (!product || !product.name) {
                showToast('El producto necesita un nombre para generar una descripción.', 'error');
                return;
            }

            const originalIcon = buttonElement.innerHTML;
            buttonElement.innerHTML = `<div class="w-4 h-4 border-2 border-purple-400 border-t-transparent rounded-full animate-spin"></div>`;
            buttonElement.disabled = true;

            const prompt = `Genera una descripción de producto concisa y atractiva (máximo 2-3 frases) para el siguiente componente de PC: "${product.name}". Enfócate en el público gamer y creador de contenido de Argentina. Destaca su característica principal.`;

            try {
                const responseText = await callGeminiAPI(prompt);
                const cleanText = responseText.replace(/[*_]/g, '');

                const textarea = document.querySelector(`#row-${categoryKey}-${index} textarea`);
                if (textarea) {
                    textarea.value = cleanText;
                    updateProduct(categoryKey, index, 'description', cleanText);
                }
                showToast('Descripción generada con IA.');
            } catch (error) {
                console.error('Error generating description:', error);
                showToast('Error al generar la descripción.', 'error');
            } finally {
                buttonElement.innerHTML = originalIcon;
                buttonElement.disabled = false;
            }
        }


        // --- Category Navigation ---

        function renderCategoryNavbar() {
            const navbar = document.getElementById('category-navbar');
            if (!navbar) return;
            navbar.innerHTML = CATEGORY_NAV_LIST.map(cat => {
                const targetId = cat.key.includes('Options') ? `table-container-${cat.key}` : cat.key;
                return `<button class="cat-nav-btn" data-cat="${targetId}" onclick="scrollToCategory('${targetId}')">${cat.label}</button>`
            }).join('');
            updateNavbarSpacer();
        }

        function updateNavbarSpacer() {
            const navbar = document.getElementById('category-navbar');
            const spacer = document.getElementById('category-navbar-spacer');
            if (navbar && spacer) {
                spacer.style.height = `${navbar.offsetHeight}px`;
            }
        }

        function scrollToCategory(targetId) {
            document.querySelectorAll('.category-navbar .cat-nav-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.cat === targetId);
            });

            const categoryDiv = document.getElementById(targetId);
            if (categoryDiv) {
                const navbarHeight = document.getElementById('category-navbar').offsetHeight;
                const elementPosition = categoryDiv.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - navbarHeight - 20;

                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
            }
        }

        // --- Helper & Utility Functions ---

        function formatTimestamp(isoString) {
            if (!isoString) return 'Nunca actualizado';
            try {
                const date = new Date(isoString);
                const options = {
                    year: '2-digit', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit',
                    hour12: false
                };
                return new Intl.DateTimeFormat('es-AR', options).format(date);
            } catch (e) {
                return 'Fecha inválida';
            }
        }

        function getComponentName(type) {
            const keyWithoutOptions = type.replace('Options', '');
            const names = {
                base: 'Base', armadas: 'Armada', towers: 'Torre', ssd: 'SSD', gpu: 'GPU', psu: 'PSU',
                motherboard: 'Motherboard', cpu: 'CPU', ram: 'RAM',
                combo: 'Combo', monitor: 'Monitor', mouse: 'Mouse',
                joystick: 'Joystick', keyboard: 'Teclado',
                comboMouseTeclado: 'Combo Mouse y Teclado', auriculares: 'Auricular',
                parlantes: 'Parlante', webcam: 'Webcam', microfonos: 'Mic', wifi: 'WiFi', arosDeLuz: 'Luz', miniPc: 'MiniPC'
            };
            return names[keyWithoutOptions] || 'Componente';
        }

        function showToast(message, type = 'success') {
            const container = document.getElementById('message-container');
            const toast = document.createElement('div');
            let bgColorClass = 'bg-red-500';
            if (type === 'success') bgColorClass = 'bg-green-500';
            else if (type === 'error') bgColorClass = 'bg-red-500';
            else if (type === 'same') bgColorClass = 'bg-sky-500'; // color for 'Precio Igual'
            else if (type === 'info') bgColorClass = 'bg-sky-500';
            toast.className = `px-4 py-2 rounded-md text-white font-semibold shadow-lg ${bgColorClass}`;
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        function findComponentById(id) {
            for (const categoryKey in dataMap) {
                if (categoryKey === 'baseOptions') continue;
                const idx = (dataMap[categoryKey] || []).findIndex(p => p.id == id);
                if (idx > -1) {
                    return { component: dataMap[categoryKey][idx], categoryKey, index: idx };
                }
            }
            const baseIdx = (dataMap.baseOptions || []).findIndex(b => b.id == id);
            if (baseIdx > -1) {
                return { component: dataMap.baseOptions[baseIdx], categoryKey: 'baseOptions', index: baseIdx };
            }
            return null;
        }

        function modifyMercadoLibreLink(urlString) {
            if (!urlString || !urlString.includes('mercadolibre.com')) {
                return urlString;
            }
            try {
                const url = new URL(urlString);
                url.searchParams.set('offer_type', 'OFFICIAL_STORE');
                return url.toString();
            } catch (e) {
                console.error("Invalid URL for modification:", urlString, e);
                return urlString;
            }
        }

        function copyToClipboard(text) {
            if (!text) return;
            navigator.clipboard.writeText(text).then(function () {
                showToast(`ID "${text}" copiado.`);
            }, function (err) {
                showToast('No se pudo copiar el ID.', 'error');
                console.error('Could not copy text: ', err);
            });
        }

        // --- Data Persistence ---

        function saveDataToSessionStorage() {
            try {
                sessionStorage.setItem('productAdminData', JSON.stringify(dataMap));
            } catch (e) {
                console.error("Error saving to sessionStorage:", e);
                showToast('Error al guardar datos en la sesión.', 'error');
            }
        }

        function loadDataFromSessionStorage() {
            try {
                const storedData = sessionStorage.getItem('productAdminData');
                return storedData ? JSON.parse(storedData) : null;
            } catch (e) {
                console.error("Error loading from sessionStorage:", e);
                sessionStorage.removeItem('productAdminData');
                return null;
            }
        }

        // --- Core Data Operations ---

        function getAllIds() {
            const ids = new Set();
            for (const key in dataMap) {
                dataMap[key].forEach(item => {
                    if (item.id) ids.add(item.id);
                });
            }
            return ids;
        }

        function generateUniqueId(existingIds) {
            let newId;
            do {
                newId = Math.floor(Math.random() * 99999) + 1;
            } while (existingIds.has(newId));
            return newId;
        }

        function sanitizeAndAssignDefaults() {
            const existingIds = getAllIds();
            for (const categoryKey in dataMap) {
                if (!Array.isArray(dataMap[categoryKey])) {
                    dataMap[categoryKey] = [];
                }
                dataMap[categoryKey].forEach(item => {
                    if (!item.id || item.id.toString().includes('-default')) {
                        const newId = generateUniqueId(existingIds);
                        item.id = newId;
                        existingIds.add(newId);
                    }
                    if (item.visible === undefined) {
                        item.visible = 1;
                    }
                    delete item.image_url; // REMOVED: No longer needed
                    item.linksAlt = item.linksAlt || []; // NEW: Ensure linksAlt exists

                    if (item.prices && Array.isArray(item.prices) && item.prices.length > 0) {
                        item.price = item.prices[0].value;
                        item.lastUpd = item.prices[0].date;
                    } else if (typeof item.price === 'number') {
                        item.prices = [{
                            value: item.price,
                            date: item.lastUpd || new Date(0).toISOString()
                        }];
                    } else {
                        item.price = 0;
                        item.prices = [];
                    }

                    if (categoryKey === 'baseOptions') {
                        if (item.description === undefined) item.description = '';
                        if (item.totalram === undefined) item.totalram = 0;
                    }
                    if (categoryKey === 'miniPcOptions') {
                        if (item.cpu === undefined) item.cpu = '';
                        if (item.ram === undefined) item.ram = '';
                        if (item.ssd === undefined) item.ssd = '';
                    }
                    if (categoryKey === 'ramOptions') {
                        if (item.total === undefined) item.total = 0;
                    }
                    if (categoryKey === 'towersOptions' && item.description === undefined) {
                        item.description = '';
                    }
                    if (categoryKey === 'bundlesOptions' && item.profit === undefined) {
                        item.profit = 0;
                    }
                });
            }
        }

        function addProduct(categoryKey, productData) {
            let newProduct;
            if (productData) {
                newProduct = productData;
            } else {
                newProduct = { name: '', price: 0, link: '', visible: 1 };
                if (categoryKey === 'miniPcOptions') {
                    newProduct.cpu = '';
                    newProduct.ram = '';
                    newProduct.ssd = '';
                } else if (categoryKey === 'ramOptions') {
                    newProduct.total = 0;
                    newProduct.description = '';
                } else {
                    newProduct.description = '';
                }
            }

            if (!newProduct.id) {
                newProduct.id = generateUniqueId(getAllIds());
            }
            if (newProduct.visible === undefined) {
                newProduct.visible = 1;
            }
            newProduct.prices = [{ value: newProduct.price, date: new Date().toISOString() }];
            newProduct.lastUpd = newProduct.prices[0].date;
            newProduct.linksAlt = []; // Initialize alt links

            dataMap[categoryKey].push(newProduct);
            renderOverviewTables();
            saveDataToSessionStorage();
        }

        function removeProduct(categoryKey, index) {
            if (!dataMap[categoryKey] || index < 0 || index >= dataMap[categoryKey].length) return;
            dataMap[categoryKey].splice(index, 1);
            renderOverviewTables();
            saveDataToSessionStorage();
        }

        function updateProduct(categoryKey, index, key, value) {
            if (dataMap[categoryKey] && dataMap[categoryKey][index]) {
                const product = dataMap[categoryKey][index];

                if (key === 'price') {
                    const newTimestamp = new Date().toISOString();
                    const newPrice = value;

                    product.price = newPrice;
                    product.lastUpd = newTimestamp;

                    if (!Array.isArray(product.prices)) {
                        product.prices = [];
                    }
                    product.prices.unshift({ value: newPrice, date: newTimestamp });

                    const tableRow = document.getElementById(`row-${categoryKey}-${index}`);
                    if (tableRow) {
                        const tooltip = tableRow.querySelector('.price-history-tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = generateTooltipTable(product.prices, product.price);
                        }
                    }
                } else {
                    product[key] = value;
                }

                if (key === 'visible') {
                    const tableRow = document.getElementById(`row-${categoryKey}-${index}`);
                    if (tableRow) {
                        tableRow.classList.toggle('opacity-50', !value);
                    }
                }

                if (key === 'price' || (categoryKey === 'ramOptions' && key === 'total')) {
                    updateAllBaseTotals();
                }

                saveDataToSessionStorage();
            }
        }

        function formatPriceInput(input) {
            let raw = input.value.replace(/[^\d.]/g, ''); // Allow dots
            let num = parseInt(raw.replace(/\./g, ''), 10);
            input.value = isNaN(num) ? '' : num.toLocaleString('es-AR');
        }

        function applyPriceChangeVisuals(tableRow, oldPrice, newPrice) {
            if (oldPrice === 0 && newPrice > 0) {
                tableRow.style.backgroundColor = '';
                tableRow.dataset.priceStatus = 'default';
                const priceWrapper = tableRow.querySelector('.price-wrapper');
                if (priceWrapper) {
                    const existingIndicator = priceWrapper.querySelector('.previous-price-indicator');
                    if (existingIndicator) existingIndicator.remove();
                }
                return;
            }

            const diff = newPrice - oldPrice;
            let highlightColor = 'rgba(2, 132, 199, 0.3)'; // Blue
            let diffColor = '';
            let status = 'same';

            if (diff < 0) {
                highlightColor = 'rgba(34, 197, 94, 0.3)'; // Green
                diffColor = 'rgba(34, 197, 94, 1)';
                status = 'decreased';
            } else if (diff > 0) {
                highlightColor = 'rgba(139, 92, 246, 0.3)'; // Violet
                diffColor = 'rgba(139, 92, 246, 1)';
                status = 'increased';
            }

            tableRow.dataset.priceStatus = status;
            tableRow.style.backgroundColor = highlightColor;

            const priceWrapper = tableRow.querySelector('.price-wrapper');
            if (priceWrapper) {
                const existingIndicator = priceWrapper.querySelector('.previous-price-indicator');
                if (existingIndicator) existingIndicator.remove();

                if (diff !== 0) {
                    const indicatorContainer = document.createElement('div');
                    indicatorContainer.className = 'previous-price-indicator';

                    const oldPriceSpan = document.createElement('span');
                    oldPriceSpan.className = 'old-price-span';
                    oldPriceSpan.style.backgroundColor = '#4b5563'; // Gray
                    oldPriceSpan.textContent = `$${oldPrice.toLocaleString('es-AR')}`;

                    const diffSpan = document.createElement('span');
                    diffSpan.className = 'diff-span';
                    diffSpan.style.backgroundColor = diffColor;
                    const diffAmount = Math.round(diff / 1000);
                    diffSpan.textContent = diffAmount > 0 ? `+${diffAmount}k` : `${diffAmount}k`;

                    indicatorContainer.appendChild(oldPriceSpan);
                    indicatorContainer.appendChild(diffSpan);
                    priceWrapper.appendChild(indicatorContainer);
                }
            }
        }

        function updatePriceFromInput(input, categoryKey, index) {
            let raw = input.value.replace(/[^\d]/g, '');
            let newPrice = parseInt(raw, 10) || 0;
            const product = dataMap[categoryKey][index];
            const oldPrice = product.price;

            if (oldPrice !== newPrice) {
                updateProduct(categoryKey, index, 'price', newPrice);
                const tableRow = document.getElementById(`row-${categoryKey}-${index}`);
                applyPriceChangeVisuals(tableRow, oldPrice, newPrice);
            }
        }

        // --- Link Manager Logic (NEW) ---

        async function handleLinkManagement(categoryKey, index, event) {
            const product = dataMap[categoryKey][index];
            if (!product.link) {
                try {
                    let text = await navigator.clipboard.readText();
                    if (typeof text !== 'string' || !text.trim().startsWith('http')) {
                        showToast('El portapapeles no contiene un link válido.', 'error');
                        return;
                    }
                    product.link = modifyMercadoLibreLink(text.trim());
                    saveDataToSessionStorage();
                    renderOverviewTables();
                    showToast('Link principal añadido.');
                } catch (err) {
                    console.error("Clipboard error:", err);
                    showToast('No se pudo acceder al portapapeles.', 'error');
                }
            } else {
                toggleLinkManager(categoryKey, index, event);
            }
        }

        function toggleLinkManager(categoryKey, index, event) {
            event.stopPropagation();
            const managerId = `link-manager-${categoryKey}-${index}`;

            if (openLinkManagerId && openLinkManagerId !== managerId) {
                const oldManager = document.getElementById(openLinkManagerId);
                if (oldManager) oldManager.classList.add('hidden');
            }

            const manager = document.getElementById(managerId);
            if (manager.classList.contains('hidden')) {
                renderLinkManager(categoryKey, index);
                manager.classList.remove('hidden');
                openLinkManagerId = managerId;
            } else {
                manager.classList.add('hidden');
                openLinkManagerId = null;
            }
        }

        function renderLinkManager(categoryKey, index) {
            const managerId = `link-manager-${categoryKey}-${index}`;
            const container = document.getElementById(managerId);
            const product = dataMap[categoryKey][index];

            let altLinksHtml = (product.linksAlt || []).map((link, altIndex) => `
            <div class="flex items-center justify-between p-2 hover:bg-gray-700/50 rounded">
                <a href="${link}" target="_blank" class="text-xs text-blue-400 hover:text-blue-300 truncate flex-1" title="${link}">${link}</a>
                <div class="flex-shrink-0 flex items-center">
                    <button onclick="setMainLink('${categoryKey}', ${index}, ${altIndex})" class="text-green-400 hover:text-green-300" title="Establecer como principal">
                         <span class="lucide-icon w-4 h-4" data-lucide="arrow-up-circle"></span>
                    </button>
                    <button onclick="deleteAltLink('${categoryKey}', ${index}, ${altIndex})" class="text-red-500 hover:text-red-400 ml-2" title="Eliminar link alternativo">
                        <span class="lucide-icon w-4 h-4" data-lucide="x-circle"></span>
                    </button>
                </div>
            </div>
        `).join('');

            container.innerHTML = `
            <div class="p-2 space-y-2">
                <div class="font-bold text-sm border-b border-gray-600 pb-2 mb-2">Gestionar Links</div>
                <div class="space-y-1 max-h-40 overflow-y-auto">
                    ${altLinksHtml || '<div class="text-xs text-gray-500 p-2">No hay links alternativos.</div>'}
                </div>
                <button onclick="addAltLinkFromClipboard('${categoryKey}', ${index})" class="w-full text-xs py-1 px-2 btn btn-secondary mt-2">
                    <span class="lucide-icon mr-1 w-4 h-4" data-lucide="clipboard-plus"></span>
                    Añadir desde Portapapeles
                </button>
            </div>
        `;
            lucide.createIcons();
        }

        async function addAltLinkFromClipboard(categoryKey, index) {
            try {
                let text = await navigator.clipboard.readText();
                if (typeof text !== 'string' || !text.trim().startsWith('http')) {
                    showToast('El portapapeles no contiene un link válido.', 'error');
                    return;
                }
                const newLink = modifyMercadoLibreLink(text.trim());
                const product = dataMap[categoryKey][index];
                if (!product.linksAlt) {
                    product.linksAlt = [];
                }
                product.linksAlt.push(newLink);
                saveDataToSessionStorage();
                renderLinkManager(categoryKey, index);
                showToast('Link alternativo añadido.');
            } catch (err) {
                console.error("Clipboard error:", err);
                showToast('No se pudo acceder al portapapeles.', 'error');
            }
        }

        function deleteAltLink(categoryKey, index, altIndex) {
            const product = dataMap[categoryKey][index];
            if (product && product.linksAlt) {
                product.linksAlt.splice(altIndex, 1);
                saveDataToSessionStorage();
                renderLinkManager(categoryKey, index);
                showToast('Link alternativo eliminado.');
            }
        }

        function setMainLink(categoryKey, index, altIndex) {
            const product = dataMap[categoryKey][index];
            if (product && product.linksAlt && product.linksAlt[altIndex]) {
                const oldMainLink = product.link;
                const newMainLink = product.linksAlt[altIndex];

                product.link = newMainLink;
                product.linksAlt.splice(altIndex, 1);
                if (oldMainLink) {
                    product.linksAlt.push(oldMainLink);
                }

                saveDataToSessionStorage();
                showToast('Link principal actualizado.');
                renderOverviewTables(); // Re-render everything to update main link and close manager
            }
        }


        // --- UI Rendering ---

        function showImagePreview(productId) {
            const preview = document.getElementById('image-preview');
            const img = preview.querySelector('img');
            if (productId) {
                img.src = `comps/${productId}.webp`;
                preview.classList.remove('hidden');
            }
        }

        function hideImagePreview() {
            document.getElementById('image-preview').classList.add('hidden');
        }

        // --- BASES Section Rendering ---
        // --- BUNDLES Section Rendering (new) ---
        let selectedBundleIndex = 0;

        function renderBundlesSection() {
            const container = document.getElementById('bundles-section');
            if (!dataMap.bundlesOptions) dataMap.bundlesOptions = [];
            if (dataMap.bundlesOptions.length === 0) {
                dataMap.bundlesOptions.push({ id: generateUniqueId(getAllIds()), name: 'Nuevo Bundle', items: [], visible: 1, description: '' });
            }

            container.innerHTML = `
            <div class="flex flex-col gap-2">
                <div id="bundle-list" class="flex flex-col gap-2 mb-4">
                    ${dataMap.bundlesOptions.map((b, i) => {
                const baseTotal = computeBundleTotal(b);
                const finalPrice = baseTotal + (b.profit || 0);
                return `
                        <div id="bundle-item-${i}" class="list-item ${i === selectedBundleIndex ? 'active' : ''}" onclick="selectBundle(${i})">
                            <div class="flex-grow">
                                <p class="font-bold truncate">${b.name || 'Sin Nombre'}</p>
                                <p class="text-xs opacity-75 truncate">ID: ${b.id}</p>
                                <div class="mt-1">
                                    <p class="font-bold text-lg text-teal-400">$${finalPrice.toLocaleString('es-AR')}</p>
                                    ${b.profit ? `<p class="text-xs opacity-75">$${baseTotal.toLocaleString('es-AR')} + $${b.profit.toLocaleString('es-AR')} Ganancia</p>` : ''}
                                </div>
                            </div>
                        </div>
                        `;
            }).join('')}
                </div>
                <div class="flex gap-2">
                    <button onclick="addBundle()" class="btn btn-primary w-full text-sm py-2"><span class="lucide-icon mr-2" data-lucide="plus"></span> Añadir Bundle</button>
                    <button onclick="cloneSelectedBundle()" class="btn btn-secondary w-auto px-3 py-2" title="Clonar Bundle Seleccionado"><span class="lucide-icon" data-lucide="copy"></span></button>
                    <button onclick="deleteSelectedBundle()" class="btn btn-danger w-auto px-3 py-2" title="Eliminar Bundle Seleccionado"><span class="lucide-icon" data-lucide="trash-2"></span></button>
                </div>
            </div>
            <div id="bundle-details" class="bg-gray-800 p-4 rounded-lg border border-gray-700">
                <!-- Details rendered here -->
            </div>
        `;

            renderSelectedBundleDetails();
            lucide.createIcons();
        }

        function selectBundle(index) {
            selectedBundleIndex = index;
            renderBundlesSection();
        }

        function addBundle() {
            const newBundle = { id: generateUniqueId(getAllIds()), name: 'Nuevo Bundle', items: [], visible: 1, description: '', profit: 0 };
            dataMap.bundlesOptions.push(newBundle);
            selectedBundleIndex = dataMap.bundlesOptions.length - 1;
            renderBundlesSection();
            saveDataToSessionStorage();
        }

        function cloneSelectedBundle() {
            const src = dataMap.bundlesOptions[selectedBundleIndex];
            if (!src) {
                showToast('No hay bundle seleccionado para clonar.', 'error');
                return;
            }
            const existingIds = getAllIds();
            const clone = JSON.parse(JSON.stringify(src));
            clone.id = generateUniqueId(existingIds);
            clone.name = (clone.name || 'Bundle') + ' (copia)';
            // ensure nested arrays exist
            clone.items = Array.isArray(clone.items) ? clone.items.slice() : [];
            dataMap.bundlesOptions.push(clone);
            selectedBundleIndex = dataMap.bundlesOptions.length - 1;
            renderBundlesSection();
            saveDataToSessionStorage();
            showToast('Bundle clonado.');
        }

        function deleteSelectedBundle() {
            if (!dataMap.bundlesOptions || dataMap.bundlesOptions.length === 0) return;
            dataMap.bundlesOptions.splice(selectedBundleIndex, 1);
            selectedBundleIndex = Math.max(0, selectedBundleIndex - 1);
            renderBundlesSection();
            saveDataToSessionStorage();
        }

        function computeBundleTotal(bundle) {
            if (!bundle || !Array.isArray(bundle.items)) return 0;
            let total = 0;
            bundle.items.forEach(it => {
                // items stored as {categoryKey, id}
                const found = findComponentById(it.id);
                if (!found || !found.component) return;
                if (found.categoryKey === 'baseOptions') {
                    // For bases, the price to use is the precomputed 'total' property
                    const v = typeof found.component.total === 'number' ? found.component.total : 0;
                    total += v;
                } else if (typeof found.component.price === 'number') {
                    total += found.component.price;
                }
            });
            return total;
        }

        function renderSelectedBundleDetails() {
            const detailsContainer = document.getElementById('bundle-details');
            const bundle = dataMap.bundlesOptions[selectedBundleIndex];
            if (!bundle) {
                detailsContainer.innerHTML = '<p>No hay un bundle seleccionado.</p>';
                return;
            }
            if (bundle.profit === undefined) bundle.profit = 0;

            // build a single category dropdown and a dependent component dropdown
            const categoryKeys = Object.keys(dataMap).filter(k => Array.isArray(dataMap[k]) && k !== 'bundlesOptions');
            const categoryOptionsHtml = categoryKeys.map(k => `<option value="${k}">${getComponentName(k)}</option>`).join('');
            const categorySelectors = `
            <div>
                <label class="block text-sm font-medium mb-1">Categoría</label>
                <select id="bundle-category-select" class="w-full bg-gray-800 border border-gray-700 text-gray-200 p-2 rounded" onchange="populateComponentsForCategory(this.value)">
                    <option value="">-- Seleccione categoría --</option>
                    ${categoryOptionsHtml}
                </select>
            </div>
            <div>
                <label class="block text-sm font-medium mb-1">Componente</label>
                <select id="bundle-component-select" class="w-full bg-gray-800 border border-gray-700 text-gray-200 p-2 rounded">
                    <option value="">-- Seleccione componente --</option>
                </select>
            </div>
        `;

            const itemsHtml = (bundle.items || []).map((it, idx) => {
                const found = findComponentById(it.id);
                let titleHtml;
                let priceDisplay = '';
                if (found) {
                    const comp = found.component;
                    const compName = comp.name || `ID: ${it.id}`;
                    // price: for bases use total, otherwise use price
                    const price = found.categoryKey === 'baseOptions' ? (comp.total || 0) : (comp.price || 0);
                    priceDisplay = `<span class="text-teal-300 font-medium ml-2">$${price.toLocaleString('es-AR')}</span>`;
                    // clickable name to scroll to component
                    titleHtml = `<a href="#" onclick="event.preventDefault(); scrollToComponent('${found.categoryKey}', ${found.index});" class="text-sm text-gray-100 hover:underline truncate">${escapeHtml(compName)}</a> <span class="text-xs text-gray-400">(${getComponentName(found.categoryKey)})</span>`;
                } else {
                    titleHtml = `<span class="text-sm">ID: ${it.id}</span>`;
                }

                return `<div class="flex items-center justify-between p-2 border-b border-gray-700"><div class="truncate">${titleHtml}${priceDisplay}</div><div class="flex items-center gap-2"><button onclick="removeItemFromBundle(${selectedBundleIndex}, ${idx})" class="text-red-400" title="Remover"><span class="lucide-icon" data-lucide="x"></span></button></div></div>`;
            }).join('') || '<div class="text-xs text-gray-500 p-2">No hay componentes añadidos.</div>';

            detailsContainer.innerHTML = `
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium mb-1">Nombre del Bundle</label>
                    <input type="text" value="${bundle.name || ''}" oninput="updateBundle('name', this.value)" class="w-full bg-gray-800 border border-gray-700 text-gray-200 p-2 rounded">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Ganancia (Bundle)</label>
                    <div class="relative">
                        <span class="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 font-bold">$</span>
                        <input type="text" value="${(bundle.profit || 0).toLocaleString('es-AR')}" 
                            oninput="formatPriceInput(this)"
                            onchange="updateBundle('profit', this.value)"
                            class="w-full pl-7 bg-gray-900 border-gray-700 text-teal-400 font-bold rounded-md" 
                            placeholder="0">
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">ID</label>
                    <div class="w-full p-2 bg-gray-900 rounded-md text-xs font-mono text-gray-400 truncate">${bundle.id}</div>
                </div>
                <div class="md:col-span-2">
                    <label class="block text-sm font-medium mb-1">Descripción</label>
                    <textarea oninput="updateBundle('description', this.value)" class="w-full bg-gray-800 border border-gray-700 text-gray-200 p-2 rounded" rows="2">${bundle.description || ''}</textarea>
                </div>
            </div>
            <div class="mb-4">
                <div class="font-semibold mb-2">Componentes en el Bundle</div>
                <div class="border border-gray-700 rounded">${itemsHtml}</div>
            </div>
            <div class="mb-4 grid grid-cols-1 md:grid-cols-2 gap-3">
                <div>
                    <label class="block text-sm font-medium mb-1">Añadir componente</label>
                    <div class="grid grid-cols-2 gap-2">${categorySelectors}</div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Acciones</label>
                    <div class="flex gap-2">
                        <button onclick="addSelectedComponentToBundle()" class="btn btn-primary">Añadir seleccionado</button>
                    </div>
                    <div class="mt-4">
                        <div class="text-sm text-gray-300">Total Componentes:</div>
                        <div class="text-lg font-bold text-gray-300">$${computeBundleTotal(bundle).toLocaleString('es-AR')}</div>
                        <div class="text-sm text-gray-300 mt-2">Total Estimado (incl. Ganancia):</div>
                        <div class="text-2xl font-bold text-teal-400">$${(computeBundleTotal(bundle) + (bundle.profit || 0)).toLocaleString('es-AR')}</div>
                    </div>
                </div>
            </div>
        `;

            lucide.createIcons();
        }

        function updateBundle(key, value) {
            const bundle = dataMap.bundlesOptions[selectedBundleIndex];
            if (!bundle) return;

            if (key !== 'profit' && key !== 'name' && key !== 'description') {
                bundle[key] = value;
            }

            if (key === 'profit') {
                let raw = value.replace(/[^\d]/g, '');
                bundle.profit = parseInt(raw, 10) || 0;
                renderBundlesSection(); // full re-render for profit to update totals everywhere
            } else if (key === 'name') {
                bundle.name = value;
                // update the left-list item title in-place if present
                const bundleItemDiv = document.getElementById(`bundle-item-${selectedBundleIndex}`);
                if (bundleItemDiv) {
                    const titleP = bundleItemDiv.querySelector('p.font-bold');
                    if (titleP) titleP.textContent = value || 'Sin Nombre';
                    // also update displayed total in the list in case prices changed elsewhere
                    const priceP = bundleItemDiv.querySelector('p.text-teal-400');
                    if (priceP) priceP.textContent = `$${computeBundleTotal(bundle).toLocaleString('es-AR')}`;
                }
            } else if (key === 'description') {
                bundle.description = value;
                // description lives in the details pane (the textarea calling this),
                // so no UI update is required here to keep focus intact. We'll persist below.
            } else {
                // for structural changes (visibility, items, etc) re-render to reflect updates
                renderBundlesSection();
            }

            saveDataToSessionStorage();
        }

        function addSelectedComponentToBundle() {
            const bundle = dataMap.bundlesOptions[selectedBundleIndex];
            if (!bundle) return;
            const categorySelect = document.getElementById('bundle-category-select');
            const compSelect = document.getElementById('bundle-component-select');
            if (!categorySelect || !compSelect || !categorySelect.value || !compSelect.value) { showToast('Seleccione categoría y componente.', 'error'); return; }
            const categoryKey = categorySelect.value;
            const id = Number(compSelect.value);
            bundle.items = bundle.items || [];
            bundle.items.push({ categoryKey, id: Number(id) });
            saveDataToSessionStorage();
            // Re-render only the details pane to show the new item list and keep inputs focused.
            renderSelectedBundleDetails();
            // Update the bundle total displayed in the left list in-place to avoid replacing the list DOM.
            const bundleItemDiv = document.getElementById(`bundle-item-${selectedBundleIndex}`);
            if (bundleItemDiv) {
                const priceP = bundleItemDiv.querySelector('p.text-teal-400');
                if (priceP) priceP.textContent = `$${computeBundleTotal(bundle).toLocaleString('es-AR')}`;
            }
        }

        function populateComponentsForCategory(categoryKey) {
            const compSelect = document.getElementById('bundle-component-select');
            if (!compSelect) return;
            compSelect.innerHTML = '<option value="">-- Seleccione componente --</option>';
            if (!categoryKey || !dataMap[categoryKey]) return;
            dataMap[categoryKey].forEach(c => {
                const opt = document.createElement('option');
                opt.value = c.id;
                opt.textContent = `${c.name} ($${(c.price || 0).toLocaleString('es-AR')})`;
                compSelect.appendChild(opt);
            });
        }

        function removeItemFromBundle(bundleIndex, itemIndex) {
            const bundle = dataMap.bundlesOptions[bundleIndex];
            if (!bundle || !bundle.items) return;
            bundle.items.splice(itemIndex, 1);
            saveDataToSessionStorage();
            // Update details pane and update left-list total in-place to avoid stealing focus.
            renderSelectedBundleDetails();
            const bundleItemDiv = document.getElementById(`bundle-item-${bundleIndex}`);
            if (bundleItemDiv) {
                const priceP = bundleItemDiv.querySelector('p.text-teal-400');
                if (priceP) priceP.textContent = `$${computeBundleTotal(bundle).toLocaleString('es-AR')}`;
            }
        }

        function scrollToComponent(categoryKey, index) {
            // If it's a base, select that base in bases section and scroll to it
            if (categoryKey === 'baseOptions') {
                // Ensure bases section is rendered and selected
                selectedBaseIndex = index;
                renderBasesSection();
                // scroll to bases section container
                const elem = document.getElementById(`base-item-${index}`);
                if (elem) {
                    const navbarHeight = document.getElementById('category-navbar').offsetHeight || 0;
                    const elementPosition = elem.getBoundingClientRect().top;
                    const offsetPosition = elementPosition + window.pageYOffset - navbarHeight - 20;
                    window.scrollTo({ top: offsetPosition, behavior: 'smooth' });
                    elem.style.transition = 'background-color 0.5s ease-in-out';
                    elem.style.backgroundColor = 'rgba(99, 102, 241, 0.5)';
                    setTimeout(() => { elem.style.backgroundColor = ''; }, 2000);
                }
                return;
            }

            // For other categories, scroll to the table row if present
            const rowId = `row-${categoryKey}-${index}`;
            const row = document.getElementById(rowId);
            if (row) {
                const navbarHeight = document.getElementById('category-navbar').offsetHeight || 0;
                const elementPosition = row.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - navbarHeight - 20;
                window.scrollTo({ top: offsetPosition, behavior: 'smooth' });
                row.style.transition = 'background-color 0.5s ease-in-out';
                row.style.backgroundColor = 'rgba(99, 102, 241, 0.5)';
                setTimeout(() => { row.style.backgroundColor = ''; }, 2000);
            } else {
                showToast('No se encontró el componente en la página (posiblemente fue eliminado).', 'error');
            }
        }

        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe.replace(/[&<>"'`]/g, function (m) { return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": "&#39;", "`": "&#96;" })[m]; });
        }

        function renderBasesSection() {
            const container = document.getElementById('bases-section');
            if (!dataMap.baseOptions) dataMap.baseOptions = [];
            if (dataMap.baseOptions.length === 0) {
                dataMap.baseOptions.push({ id: generateUniqueId(getAllIds()), name: 'Nueva Base', cpu: null, mother: null, ram: null, cantRam: 1, total: 0, visible: 1, description: '', totalram: 0 });
            }

            container.innerHTML = `
            <div class="flex flex-col gap-2">
                <div id="base-list" class="flex flex-col gap-2 mb-4">
                    ${dataMap.baseOptions.map((base, index) => {
                return `
                        <div id="base-item-${index}" class="list-item ${index === selectedBaseIndex ? 'active' : ''}" onclick="selectBase(${index})">
                            <div class="flex-grow">
                                <p class="font-bold truncate">${base.name || 'Sin Nombre'}</p>
                                <p class="text-xs opacity-75 truncate">${base.id || 'Sin ID'}</p>
                                <p class="font-bold text-lg text-teal-400 mt-1">$${(base.total || 0).toLocaleString('es-AR')}</p>
                            </div>
                        </div>
                        `
            }).join('')}
                </div>
                <div class="flex gap-2">
                    <button onclick="addBase()" class="btn btn-primary w-full text-sm py-2">
                        <span class="lucide-icon mr-2" data-lucide="plus"></span> Añadir Base
                    </button>
                    <button onclick="deleteSelectedBase()" class="btn btn-danger w-auto px-3 py-2" title="Eliminar Base Seleccionada">
                        <span class="lucide-icon" data-lucide="trash-2"></span>
                    </button>
                </div>
            </div>
            <div id="base-details" class="bg-gray-800 p-4 rounded-lg border border-gray-700">
                <!-- Details of selected base will be rendered here -->
            </div>
        `;
            renderSelectedBaseDetails();
            lucide.createIcons();
        }

        function renderSelectedBaseDetails() {
            const detailsContainer = document.getElementById('base-details');
            const base = dataMap.baseOptions[selectedBaseIndex];

            if (!base) {
                detailsContainer.innerHTML = '<p>No hay una base seleccionada.</p>';
                return;
            }

            const cpuIndex = dataMap.cpuOptions.findIndex(c => c.id == base.cpu);
            const motherIndex = dataMap.motherboardOptions.findIndex(m => m.id == base.mother);
            const ramIndex = dataMap.ramOptions.findIndex(r => r.id == base.ram);

            const cpuOptions = dataMap.cpuOptions.map(c => `<option value="${c.id}" ${base.cpu == c.id ? 'selected' : ''}>${c.name} ($${(c.price || 0).toLocaleString('es-AR')})</option>`).join('');
            const motherOptions = dataMap.motherboardOptions.map(m => `<option value="${m.id}" ${base.mother == m.id ? 'selected' : ''}>${m.name} ($${(m.price || 0).toLocaleString('es-AR')})</option>`).join('');
            const ramOptions = dataMap.ramOptions.map(r => `<option value="${r.id}" ${base.ram == r.id ? 'selected' : ''}>${r.name} ($${(r.price || 0).toLocaleString('es-AR')})</option>`).join('');

            detailsContainer.innerHTML = `
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                 <div>
                    <label class="block text-sm font-medium mb-1">Nombre de la Base</label>
                    <input type="text" value="${base.name || ''}" oninput="updateBase('name', this.value)" class="w-full">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">ID</label>
                    <div class="w-full p-2 bg-gray-900 rounded-md text-xs font-mono text-gray-400 truncate">${base.id}</div>
                </div>
                <div class="md:col-span-2">
                    <label class="block text-sm font-medium mb-1">Descripción</label>
                    <textarea oninput="updateBase('description', this.value)" class="w-full" rows="2">${base.description || ''}</textarea>
                </div>
            </div>
            <div class="space-y-4 mb-4">
                <div>
                    <label class="block text-sm font-medium mb-1">CPU</label>
                    <div class="flex items-center gap-2">
                        <select onchange="updateBase('cpu', this.value)" class="flex-grow">
                            <option value="">Seleccionar CPU...</option>
                            ${cpuOptions}
                        </select>
                        <a href="#row-cpuOptions-${cpuIndex}" onclick="scrollToComponentRow('cpuOptions', ${cpuIndex})" class="${cpuIndex > -1 ? 'inline-flex' : 'hidden'} text-blue-400 hover:text-blue-300" title="Ir al componente">
                             <span class="lucide-icon" data-lucide="link"></span>
                        </a>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Motherboard</label>
                     <div class="flex items-center gap-2">
                        <select onchange="updateBase('mother', this.value)" class="flex-grow">
                            <option value="">Seleccionar Motherboard...</option>
                            ${motherOptions}
                        </select>
                        <a href="#row-motherboardOptions-${motherIndex}" onclick="scrollToComponentRow('motherboardOptions', ${motherIndex})" class="${motherIndex > -1 ? 'inline-flex' : 'hidden'} text-blue-400 hover:text-blue-300" title="Ir al componente">
                             <span class="lucide-icon" data-lucide="link"></span>
                        </a>
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-4">
                    <div class="col-span-2">
                        <label class="block text-sm font-medium mb-1">RAM</label>
                        <div class="flex items-center gap-2">
                            <select onchange="updateBase('ram', this.value)" class="flex-grow">
                                <option value="">Seleccionar RAM...</option>
                                ${ramOptions}
                            </select>
                             <a href="#row-ramOptions-${ramIndex}" onclick="scrollToComponentRow('ramOptions', ${ramIndex})" class="${ramIndex > -1 ? 'inline-flex' : 'hidden'} text-blue-400 hover:text-blue-300" title="Ir al componente">
                                <span class="lucide-icon" data-lucide="link"></span>
                            </a>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">Cantidad</label>
                        <div class="flex items-center justify-between gap-1">
                            ${[1, 2, 3, 4].map(n => `<button class="btn ram-qty-btn w-full text-xs py-2 px-0 ${base.cantRam == n ? 'active' : ''}" onclick="updateBase('cantRam', ${n})">${n}</button>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                 <div class="md:col-span-1">
                    <label class="block text-sm font-medium mb-1">Total de la Base</label>
                    <div class="w-full p-2 bg-gray-900 rounded-md text-lg font-bold text-teal-400">
                        $${(base.total || 0).toLocaleString('es-AR')}
                    </div>
                </div>
                 <div class="md:col-span-1">
                    <label class="block text-sm font-medium mb-1">Total RAM (GB)</label>
                    <div class="w-full p-2 bg-gray-900 rounded-md text-lg font-bold text-teal-400">
                        ${base.totalram || 0} GB
                    </div>
                </div>
                <div class="md:col-span-2 flex items-center justify-center pt-2">
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" ${base.visible ? 'checked' : ''} onchange="updateBase('visible', this.checked ? 1 : 0)" class="w-5 h-5 rounded text-indigo-500 bg-gray-700 border-gray-600 focus:ring-indigo-600">
                        <span class="font-medium">Visible</span>
                    </label>
                </div>
            </div>
            <div class="mt-6">
                <button onclick="analyzeSelectedBase()" class="btn btn-primary w-full bg-gradient-to-r from-purple-500 to-indigo-600 hover:from-purple-600 hover:to-indigo-700">
                    <span class="lucide-icon mr-2" data-lucide="sparkles"></span> ✨ Analizar Base con IA
                </button>
            </div>
        `;
            lucide.createIcons();
        }

        // --- BASES Data Operations ---
        function calculateBaseTotal(base) {
            if (!base) return 0;
            const cpu = dataMap.cpuOptions.find(c => c.id == base.cpu);
            const mother = dataMap.motherboardOptions.find(m => m.id == base.mother);
            const ram = dataMap.ramOptions.find(r => r.id == base.ram);
            const cantRam = base.cantRam || 1;

            const cpuPrice = cpu ? cpu.price || 0 : 0;
            const motherPrice = mother ? mother.price || 0 : 0;
            const ramPrice = ram ? ram.price || 0 : 0;

            return cpuPrice + motherPrice + (ramPrice * cantRam);
        }

        function calculateBaseRamTotal(base) {
            if (!base || !base.ram) return 0;
            const ram = dataMap.ramOptions.find(r => r.id == base.ram);
            const cantRam = base.cantRam || 1;
            const ramTotal = ram ? ram.total || 0 : 0;
            return ramTotal * cantRam;
        }

        function updateAllBaseTotals() {
            dataMap.baseOptions.forEach(base => {
                base.total = calculateBaseTotal(base);
                base.totalram = calculateBaseRamTotal(base);
            });
            // After recalculating base totals, update any visible bundle totals in-place
            updateAllBundleTotalsInPlace();
        }

        function updateAllBundleTotalsInPlace() {
            if (!Array.isArray(dataMap.bundlesOptions)) return;
            dataMap.bundlesOptions.forEach((b, i) => {
                const bundleItemDiv = document.getElementById(`bundle-item-${i}`);
                if (bundleItemDiv) {
                    const priceP = bundleItemDiv.querySelector('p.text-teal-400');
                    if (priceP) priceP.textContent = `$${computeBundleTotal(b).toLocaleString('es-AR')}`;
                }
            });
        }

        function selectBase(index) {
            selectedBaseIndex = index;
            renderBasesSection();
        }

        function addBase() {
            dataMap.baseOptions.push({
                id: generateUniqueId(getAllIds()),
                name: 'Nueva Base',
                cpu: null, mother: null, ram: null, cantRam: 1,
                total: 0,
                visible: 1,
                description: '',
                totalram: 0
            });
            selectedBaseIndex = dataMap.baseOptions.length - 1;
            renderBasesSection();
            saveDataToSessionStorage();
        }

        function deleteSelectedBase() {
            if (dataMap.baseOptions.length <= 1) {
                showToast('No se puede eliminar la última base.', 'error');
                return;
            }
            dataMap.baseOptions.splice(selectedBaseIndex, 1);
            if (selectedBaseIndex >= dataMap.baseOptions.length) {
                selectedBaseIndex = dataMap.baseOptions.length - 1;
            }
            renderBasesSection();
            saveDataToSessionStorage();
        }

        function updateBase(key, value) {
            const base = dataMap.baseOptions[selectedBaseIndex];
            if (base) {
                base[key] = value;

                if (key === 'cpu') {
                    const cpu = dataMap.cpuOptions.find(c => c.id == value);
                    if (cpu) {
                        base.name = cpu.name;
                    }
                }

                base.total = calculateBaseTotal(base);
                base.totalram = calculateBaseRamTotal(base);
                saveDataToSessionStorage();

                if (['cpu', 'mother', 'ram', 'cantRam'].includes(key)) {
                    renderBasesSection();
                } else if (key === 'name') {
                    const baseItemDiv = document.getElementById(`base-item-${selectedBaseIndex}`);
                    if (baseItemDiv) {
                        baseItemDiv.querySelector('p.font-bold').textContent = value || 'Sin Nombre';
                    }
                }
            }
        }

        function scrollToComponentRow(categoryKey, index) {
            const rowId = `row-${categoryKey}-${index}`;
            const row = document.getElementById(rowId);
            if (row) {
                const navbarHeight = document.getElementById('category-navbar').offsetHeight;
                const elementPosition = row.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - navbarHeight - 20;

                window.scrollTo({ top: offsetPosition, behavior: 'smooth' });

                row.style.transition = 'background-color 0.5s ease-in-out';
                row.style.backgroundColor = 'rgba(99, 102, 241, 0.5)';
                setTimeout(() => {
                    row.style.backgroundColor = '';
                }, 2000);
            }
        }

        function generateTooltipTable(prices, currentPrice) {
            // prices: array newest-first ({value, date})
            if (!prices || prices.length === 0) {
                // If no stored prices but we have a currentPrice, show it as Hoy
                if (typeof currentPrice === 'number' && currentPrice > 0) {
                    const now = new Date();
                    const time = new Intl.DateTimeFormat('es-AR', { hour: '2-digit', minute: '2-digit', hour12: false }).format(now);
                    return `<table class="tooltip-table"><thead><tr><th>Fecha</th><th>Precio</th></tr></thead><tbody><tr><td>Hoy ${time}</td><td>$${currentPrice.toLocaleString('es-AR')}</td></tr></tbody></table>`;
                }
                return '<span>Sin historial de precios.</span>';
            }

            // Make a shallow copy to avoid mutating original
            const copy = prices.slice();
            const todayKey = new Date().toISOString().slice(0, 10);

            // If the list doesn't already include an entry for today, prepend the currentPrice as 'Hoy'
            const hasToday = copy.some(p => {
                try {
                    return new Date(p.date).toISOString().slice(0, 10) === todayKey;
                } catch (e) {
                    return false;
                }
            });

            if (!hasToday && typeof currentPrice === 'number' && currentPrice > 0) {
                copy.unshift({ value: currentPrice, date: new Date().toISOString() });
            }

            const recentPrices = copy.slice(0, 7);
            let tableHTML = '<table class="tooltip-table"><thead><tr><th>Fecha</th><th>Precio</th></tr></thead><tbody>';
            recentPrices.forEach(p => {
                let dateLabel = '';
                try {
                    const d = new Date(p.date);
                    const key = d.toISOString().slice(0, 10);
                    if (key === todayKey) {
                        const time = new Intl.DateTimeFormat('es-AR', { hour: '2-digit', minute: '2-digit', hour12: false }).format(d);
                        dateLabel = `Hoy ${time}`;
                    } else {
                        dateLabel = formatTimestamp(p.date);
                    }
                } catch (e) {
                    dateLabel = formatTimestamp(p.date);
                }

                tableHTML += `<tr><td>${dateLabel}</td><td>$${p.value.toLocaleString('es-AR')}</td></tr>`;
            });
            tableHTML += '</tbody></table>';
            return tableHTML;
        }

        function renderOverviewTables() {
            const overviewContainer = document.getElementById('overview-view');
            overviewContainer.innerHTML = '';

            CATEGORY_NAV_LIST.forEach(category => {
                const categoryKey = category.key;
                if (!categoryKey.includes('Options')) return;

                const categoryData = dataMap[categoryKey];
                const readableCategoryName = category.label;

                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'mb-8 p-6 bg-gray-900 rounded-lg shadow-sm border border-gray-700 category-table-container';
                categoryDiv.id = `table-container-${categoryKey}`;
                categoryDiv.innerHTML = `<h3 class="text-xl font-semibold text-gray-100 mb-4">${readableCategoryName}</h3>`;

                const table = document.createElement('table');
                table.className = 'overview-table w-full text-left text-sm text-gray-400';

                let headers = `
                <th scope="col" class="px-2 py-3 hidden md:table-cell" style="width: 1%;">ID</th>
                <th scope="col" class="px-2 py-3" style="width: 240px;">Nombre</th>
                <th scope="col" class="px-2 py-3 text-left" style="width: 120px;">Precio</th>
                <th scope="col" class="px-2 py-3 hidden md:table-cell">Descripción</th>
                <th scope="col" class="px-2 py-3 hidden md:table-cell" style="width: 1%;">Visible</th>
                <th scope="col" class="px-1 py-3 hidden md:table-cell" style="width:1%;min-width:150px;">Acciones</th>
            `;
                if (categoryKey === 'ramOptions') {
                    headers = `
                    <th scope="col" class="px-2 py-3 hidden md:table-cell" style="width: 1%;">ID</th>
                    <th scope="col" class="px-2 py-3" style="width: 240px;">Nombre</th>
                    <th scope="col" class="px-2 py-3 text-left" style="width: 120px;">Precio</th>
                    <th scope="col" class="px-2 py-3 hidden md:table-cell">Descripción</th>
                    <th scope="col" class="px-2 py-3 hidden md:table-cell">Total (GB)</th>
                    <th scope="col" class="px-2 py-3 hidden md:table-cell" style="width: 1%;">Visible</th>
                    <th scope="col" class="px-1 py-3 hidden md:table-cell" style="width:1%;min-width:150px;">Acciones</th>
                `;
                } else if (categoryKey === 'miniPcOptions') {
                    headers = `
                    <th scope="col" class="px-2 py-3 hidden md:table-cell" style="width: 1%;">ID</th>
                    <th scope="col" class="px-2 py-3" style="width: 240px;">Nombre</th>
                    <th scope="col" class="px-2 py-3 text-left" style="width: 120px;">Precio</th>
                    <th scope="col" class="px-2 py-3 hidden md:table-cell">CPU</th>
                    <th scope="col" class="px-2 py-3 hidden md:table-cell">RAM</th>
                    <th scope="col" class="px-2 py-3 hidden md:table-cell">SSD</th>
                    <th scope="col" class="px-2 py-3 hidden md:table-cell" style="width: 1%;">Visible</th>
                    <th scope="col" class="px-1 py-3 hidden md:table-cell" style="width:1%;min-width:150px;">Acciones</th>
                `;
                }

                let colspan = 6;
                if (categoryKey === 'ramOptions') {
                    colspan = 7;
                } else if (categoryKey === 'miniPcOptions') {
                    colspan = 8;
                }


                table.innerHTML = `
                <thead class="text-xs text-gray-200 uppercase bg-gray-700">
                    <tr>${headers}</tr>
                </thead>
                <tbody>
                    ${(categoryData || []).map((product, index) => {
                    let customColumns;
                    if (categoryKey === 'miniPcOptions') {
                        customColumns = `
                                <td class="px-2 py-2 hidden md:table-cell"><input type="text" value="${product.cpu || ''}" oninput="updateProduct('${categoryKey}', ${index}, 'cpu', this.value)" class="w-full"></td>
                                <td class="px-2 py-2 hidden md:table-cell"><input type="text" value="${product.ram || ''}" oninput="updateProduct('${categoryKey}', ${index}, 'ram', this.value)" class="w-full"></td>
                                <td class="px-2 py-2 hidden md:table-cell"><input type="text" value="${product.ssd || ''}" oninput="updateProduct('${categoryKey}', ${index}, 'ssd', this.value)" class="w-full"></td>
                            `;
                    } else if (categoryKey === 'ramOptions') {
                        customColumns = `
                                <td class="px-2 py-2 hidden md:table-cell">
                                    <div class="relative">
                                        <textarea rows="2" style="min-height:2.5em;max-height:4.5em;" oninput="updateProduct('${categoryKey}', ${index}, 'description', this.value)" class="w-full resize-none pr-8">${product.description || ''}</textarea>
                                        <button onclick="generateDescription('${categoryKey}', ${index}, this)" class="absolute bottom-2 right-2 text-purple-400 hover:text-purple-300 p-1 rounded-full bg-gray-900/50 hover:bg-gray-900" title="✨ Generar descripción con IA">
                                            <span class="lucide-icon w-4 h-4" data-lucide="sparkles"></span>
                                        </button>
                                    </div>
                                </td>
                                <td class="px-2 py-2 hidden md:table-cell">
                                    <input type="number" value="${product.total || 0}" oninput="updateProduct('${categoryKey}', ${index}, 'total', parseInt(this.value, 10) || 0)" class="w-full">
                                </td>
                            `;
                    } else {
                        customColumns = `
                            <td class="px-2 py-2 hidden md:table-cell">
                                <div class="relative">
                                    <textarea rows="2" style="min-height:2.5em;max-height:4.5em;" oninput="updateProduct('${categoryKey}', ${index}, 'description', this.value)" class="w-full resize-none pr-8">${product.description || ''}</textarea>
                                    <button onclick="generateDescription('${categoryKey}', ${index}, this)" class="absolute bottom-2 right-2 text-purple-400 hover:text-purple-300 p-1 rounded-full bg-gray-900/50 hover:bg-gray-900" title="✨ Generar descripción con IA">
                                        <span class="lucide-icon w-4 h-4" data-lucide="sparkles"></span>
                                    </button>
                                </div>
                            </td>`;
                    }

                    const priceCheckButton = product.link ? `
                            <button onclick="startSinglePriceCheckAndContinue('${categoryKey}', ${index})" class="text-teal-400 hover:text-teal-300" title="Chequear Precio y Continuar">
                                <span class="lucide-icon w-4 h-4" data-lucide="dollar-sign"></span>
                            </button>
                        ` : '';

                    const tooltipTableHTML = generateTooltipTable(product.prices, product.price);

                    const chartButton = (product.prices && product.prices.length > 1) ? `
                            <button onclick="openPriceChartPopup('${categoryKey}', ${index})" class="text-indigo-400 hover:text-indigo-300 ml-2" title="Ver Historial de Precios">
                                <span class="lucide-icon w-4 h-4" data-lucide="line-chart"></span>
                            </button>
                        ` : '';

                    const hasAltLinksClass = (product.linksAlt && product.linksAlt.length > 0) ? 'border-2 border-teal-400' : '';

                    return `
                        <tr id="row-${categoryKey}-${index}" data-price-status="default" class="border-b border-gray-700 hover:bg-gray-700/50 transition-colors duration-200 ${!product.visible ? 'opacity-50 mobile-hidden-if-not-visible' : ''}" 
                            ondragover="onRowDragOver(event)" 
                            ondrop="onRowDrop(event, '${categoryKey}', ${index})"
                            onmouseenter="showImagePreview('${product.id}')"
                            onmouseleave="hideImagePreview()">
                            <td class="px-2 py-2 text-center text-xs text-gray-400 font-mono cursor-pointer hover:text-white hidden md:table-cell" onclick="copyToClipboard('${product.id || ''}')" title="Copiar ID">${product.id || ''}</td>
                            <td class="px-2 py-2 font-medium text-white whitespace-nowrap">
                                <input type="text" value="${product.name || ''}" oninput="updateProduct('${categoryKey}', ${index}, 'name', this.value)" class="w-full">
                            </td>
                            <td class="px-2 py-2 price-cell">
                                <div class="price-wrapper">
                                    <div class="flex items-center gap-1">
                                        <span class="text-gray-400 font-semibold text-lg">$</span>
                                        <input type="text" value="${product.price ? product.price.toLocaleString('es-AR') : ''}" 
                                            oninput="formatPriceInput(this)"
                                            onchange="updatePriceFromInput(this, '${categoryKey}', ${index})"
                                            onkeydown="if(event.key === 'Enter'){ event.preventDefault(); this.blur(); }"
                                            class="text-left" style="width: 100px;">
                                    </div>
                                    <div class="price-history-tooltip">${tooltipTableHTML}</div>
                                </div>
                            </td>
                            ${customColumns}
                            <td class="px-2 py-2 text-center hidden md:table-cell">
                                <input type="checkbox" ${product.visible ? 'checked' : ''} onchange="updateProduct('${categoryKey}', ${index}, 'visible', this.checked ? 1 : 0)" class="w-5 h-5 rounded text-indigo-500 bg-gray-700 border-gray-600 focus:ring-indigo-600">
                            </td>
                            <td class="px-1 py-2 text-right hidden md:table-cell relative">
                                <div class="flex flex-col items-end gap-1">
                                    <div class="flex items-center">
                                        ${priceCheckButton}
                                        ${chartButton}
                                        <button onclick="removeProduct('${categoryKey}', ${index})" class="text-red-500 hover:text-red-700 ml-2" title="Eliminar">
                                            <span class="lucide-icon w-4 h-4" data-lucide="trash-2"></span>
                                        </button>
                                        <button draggable="true" ondragstart="onRowDragStart(event, '${categoryKey}', ${index})" class="text-gray-400 hover:text-indigo-400 ml-2 cursor-move" title="Arrastrar para reordenar">
                                            <span class="lucide-icon w-4 h-4" data-lucide="move"></span>
                                        </button>
                                    </div>
                                    <div class="flex items-center gap-1">
                                        <a href="${product.link || '#'}" target="_blank" class="btn btn-secondary min-w-0 flex items-center justify-center text-xs py-1 px-2.5" title="Visitar Link">
                                            <span class="lucide-icon" data-lucide="external-link"></span>
                                        </a>
                                        <button onclick="handleLinkManagement('${categoryKey}', ${index}, event)" class="btn btn-primary text-xs py-1 px-2.5 ml-1 ${hasAltLinksClass}" title="Gestionar Links">
                                            <span class="lucide-icon" data-lucide="edit"></span>
                                        </button>
                                    </div>
                                </div>
                                <div id="link-manager-${categoryKey}-${index}" class="link-manager-container hidden"></div>
                            </td>
                        </tr>
                    `}).join('')}
                    <tr class="hidden md:table-row">
                        <td colspan="${colspan}" class="add-row-button-cell">
                             <div class="flex justify-end items-center gap-4">
                                <button onclick="addProduct('${categoryKey}')" class="add-row-button">
                                    <span class="lucide-icon mr-2" data-lucide="plus"></span>Añadir
                                </button>
                                <button id="add-from-clipboard-${categoryKey}" onclick="addProductFromClipboard('${categoryKey}')" class="add-row-button bg-sky-600 hover:bg-sky-700">
                                    <span class="lucide-icon mr-2" data-lucide="clipboard-plus"></span>Añadir Link
                                </button>
                            </div>
                        </td>
                    </tr>
                </tbody>
            `;
                categoryDiv.appendChild(table);
                overviewContainer.appendChild(categoryDiv);
            });
            lucide.createIcons();
        }

        // --- Drag and Drop for Table Rows ---
        let dragSrcIndex = null;
        let dragSrcCategory = null;

        function onRowDragStart(event, categoryKey, index) {
            dragSrcIndex = index;
            dragSrcCategory = categoryKey;
            event.dataTransfer.effectAllowed = 'move';
        }
        function onRowDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
        }
        function onRowDrop(event, categoryKey, index) {
            event.preventDefault();
            if (dragSrcCategory === categoryKey && dragSrcIndex !== null && dragSrcIndex !== index) {
                const arr = dataMap[categoryKey];
                const moved = arr.splice(dragSrcIndex, 1)[0];
                arr.splice(index, 0, moved);
                renderOverviewTables();
                saveDataToSessionStorage();
            }
            dragSrcIndex = null;
            dragSrcCategory = null;
        }

        // --- Add Product from Clipboard (Modified) ---
        async function addProductFromClipboard(categoryKey) {
            const btn = document.getElementById(`add-from-clipboard-${categoryKey}`);
            const originalContent = btn.innerHTML;
            btn.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
            btn.disabled = true;

            try {
                let link = await navigator.clipboard.readText();
                if (!link || !link.trim().startsWith('http')) {
                    throw new Error('El portapapeles no contiene un link válido.');
                }
                link = modifyMercadoLibreLink(link.trim());

                const newId = generateUniqueId(getAllIds());

                const newProduct = {
                    id: newId,
                    name: 'Nuevo Producto desde Link',
                    price: 0,
                    link: link,
                    visible: 1
                };

                if (categoryKey === 'miniPcOptions') {
                    newProduct.cpu = '';
                    newProduct.ram = '';
                    newProduct.ssd = '';
                } else {
                    newProduct.description = '';
                }

                addProduct(categoryKey, newProduct);
                showToast('Producto añadido desde el link.');

            } catch (error) {
                console.error('Error al añadir desde clipboard:', error);
                showToast(error.message, 'error');
            } finally {
                btn.innerHTML = originalContent;
                btn.disabled = false;
                lucide.createIcons({
                    nodes: [btn.querySelector('.lucide-icon')],
                });
            }
        }

        // --- Price Check Logic ---

        function openPriceCheckPopup(categoryKey, index, isFromLoop = false) {
            const product = dataMap[categoryKey][index];
            if (!product || !product.link) return;
            // Delay opening the product link by 1 second so the popup appears first
            if (priceCheckOpenTimeout) {
                clearTimeout(priceCheckOpenTimeout);
                priceCheckOpenTimeout = null;
            }
            priceCheckOpenTimeout = setTimeout(() => {
                try { window.open(product.link, '_blank'); } catch (e) { console.error('Failed to open product link', e); }
                priceCheckOpenTimeout = null;
            }, 600);

            const popup = document.getElementById('price-check-popup');
            const title = document.getElementById('popup-title');
            const currentPriceEl = document.getElementById('popup-current-price');
            const newPriceInput = document.getElementById('popup-new-price');

            title.textContent = `Chequeando: ${product.name}`;
            currentPriceEl.textContent = `$${(product.price || 0).toLocaleString('es-AR')}`;

            newPriceInput.value = '';
            newPriceInput.dataset.categoryKey = categoryKey;
            newPriceInput.dataset.index = index;
            newPriceInput.dataset.isFromLoop = isFromLoop;

            popup.classList.remove('hidden');
            newPriceInput.focus();
        }

        function closePriceCheckPopup() {
            if (isLoopRunning) {
                pausePriceCheckLoop();
            }
            const popup = document.getElementById('price-check-popup');
            // If the popup is closed before the delayed open runs, cancel it
            if (priceCheckOpenTimeout) {
                clearTimeout(priceCheckOpenTimeout);
                priceCheckOpenTimeout = null;
            }
            popup.classList.add('hidden');
        }

        function handleManualPriceCheck(event) {
            const input = event.target;

            if (event.key === 'w' && input.value.trim() === '') {
                event.preventDefault(); // Prevent browser back navigation
                const { categoryKey, index, isFromLoop } = input.dataset;
                showToast('Producto omitido.', 'same');
                const popup = document.getElementById('price-check-popup');
                if (priceCheckOpenTimeout) { clearTimeout(priceCheckOpenTimeout); priceCheckOpenTimeout = null; }
                popup.classList.add('hidden');

                if (isFromLoop === 'true') {
                    currentQueueIndex++;
                    sessionStorage.setItem('priceCheckQueueIndex', currentQueueIndex);
                    updatePriceCheckQueueCount();
                    processNextInQueue();
                }
                return;
            }

            if (event.key !== 'Enter') return;

            const { categoryKey, index, isFromLoop } = input.dataset;
            const product = dataMap[categoryKey][index];
            const oldPrice = product.price || 0;
            let newPrice;

            if (!input.value.trim()) {
                newPrice = oldPrice;
            } else {
                const rawValue = input.value.replace(/[^\d]/g, '');
                newPrice = parseInt(rawValue, 10);
            }

            if (isNaN(newPrice) || !product) {
                showToast('Por favor, ingrese un precio válido.', 'error');
                return;
            }

            updateProduct(categoryKey, index, 'price', newPrice);

            const tableRow = document.getElementById(`row-${categoryKey}-${index}`);
            const priceInputInTable = tableRow.querySelector('.price-cell input');
            if (priceInputInTable) {
                priceInputInTable.value = newPrice.toLocaleString('es-AR');
            }

            applyPriceChangeVisuals(tableRow, oldPrice, newPrice);

            showToast(`Precio de "${product.name}" actualizado a $${newPrice.toLocaleString('es-AR')}.`);

            const popup = document.getElementById('price-check-popup');
            if (priceCheckOpenTimeout) { clearTimeout(priceCheckOpenTimeout); priceCheckOpenTimeout = null; }
            popup.classList.add('hidden');

            if (isFromLoop === 'true') {
                currentQueueIndex++;
                sessionStorage.setItem('priceCheckQueueIndex', currentQueueIndex);
                updatePriceCheckQueueCount();
                processNextInQueue();
            }
        }

        function handlePastePrice(event) {
            event.preventDefault();
            const pastedText = (event.clipboardData || window.clipboardData).getData('text');
            const numericValue = pastedText.replace(/[^\d]/g, '');

            if (numericValue) {
                const input = event.target;
                input.value = numericValue;

                const fakeEvent = {
                    key: 'Enter',
                    target: input
                };
                handleManualPriceCheck(fakeEvent);
            }
        }

        // --- Price Chart Popup Logic ---
        function openPriceChartPopup(categoryKey, index) {
            const product = dataMap[categoryKey][index];
            if (!product || !product.prices || product.prices.length === 0) {
                showToast('No hay historial de precios para este producto.', 'error');
                return;
            }

            const popup = document.getElementById('price-chart-popup');
            const title = document.getElementById('chart-popup-title');
            title.textContent = `Historial de: ${product.name}`;

            // Build a day-by-day filled history: if a day is missing, assume price stayed the same as previous day
            const rawPrices = [...product.prices].filter(p => p.value > 0);
            if (rawPrices.length === 0) {
                showToast('No hay historial de precios para este producto.', 'error');
                return;
            }
            // Sort ascending by date
            rawPrices.sort((a, b) => new Date(a.date) - new Date(b.date));

            // Map prices by day (YYYY-MM-DD)
            const priceByDay = new Map();
            rawPrices.forEach(p => {
                const d = new Date(p.date);
                const key = d.toISOString().slice(0, 10);
                priceByDay.set(key, p.value);
            });

            const startDate = new Date(rawPrices[0].date);
            const endDate = new Date(rawPrices[rawPrices.length - 1].date);

            const filled = [];
            let cursor = new Date(startDate);
            let lastValue = priceByDay.get(cursor.toISOString().slice(0, 10));
            // Ensure lastValue is initialized to the first available price
            if (lastValue === undefined) {
                // find first available
                lastValue = rawPrices[0].value;
            }
            while (cursor <= endDate) {
                const key = cursor.toISOString().slice(0, 10);
                if (priceByDay.has(key)) {
                    lastValue = priceByDay.get(key);
                }
                // store ISO full datetime for compatibility
                filled.push({ date: key + 'T00:00:00', value: lastValue });
                cursor.setDate(cursor.getDate() + 1);
            }

            // Ensure the series includes today's price (the current/latest price)
            try {
                const todayKey = new Date().toISOString().slice(0, 10);
                const lastFilledKey = filled.length ? filled[filled.length - 1].date.slice(0, 10) : null;
                const currentPrice = (product.prices && product.prices.length) ? product.prices[0].value : lastValue;

                if (lastFilledKey !== todayKey) {
                    // Fill intermediate days (if any) with the last known value, and add today's point with currentPrice
                    let cursor2 = filled.length ? new Date(filled[filled.length - 1].date) : new Date(endDate);
                    // move to the next day after last filled
                    cursor2.setDate(cursor2.getDate() + 1);
                    while (cursor2.toISOString().slice(0, 10) <= todayKey) {
                        const key = cursor2.toISOString().slice(0, 10);
                        const valueToPush = (key === todayKey) ? currentPrice : lastValue;
                        filled.push({ date: key + 'T00:00:00', value: valueToPush });
                        cursor2.setDate(cursor2.getDate() + 1);
                    }
                }
            } catch (e) {
                // If anything goes wrong with augmenting up to today, silently continue with filled as-is
            }

            const historicalData = filled;
            // Helper: compact number formatting like y-axis (e.g. 30,5k or 1,5M)
            function formatShortNumber(v) {
                const abs = Math.abs(v);
                if (abs >= 1000000) {
                    return (v / 1000000).toFixed(1).replace('.', ',') + 'M';
                } else if (abs >= 1000) {
                    return (v / 1000).toFixed(1).replace('.', ',') + 'k';
                }
                return v.toString();
            }

            // x-axis labels: day, include "/month" only when the month changes (ej. "1/9")
            const labels = [];
            let lastMonth = null;
            historicalData.forEach(p => {
                const d = new Date(p.date);
                const day = d.getDate();
                const month = d.getMonth() + 1;
                if (lastMonth === null || month !== lastMonth) {
                    labels.push(`${day}/${month}`);
                    lastMonth = month;
                } else {
                    labels.push(`${day}`);
                }
            });
            const data = historicalData.map(p => p.value);
            const latestPrice = data.length ? data[data.length - 1] : null;

            // compute minimum chart bound: start from one-fifth of the lowest positive price
            const positiveValues = data.filter(v => typeof v === 'number' && isFinite(v) && v > 0);
            const minPriceVal = positiveValues.length ? Math.min(...positiveValues) : 0;
            const minChart = minPriceVal ? Math.floor(minPriceVal * 0.8) : 0;

            // compute per-bar colors based on change vs previous day
            const backgroundColors = [];
            const borderColors = [];
            // colors matching the filter options
            const COLOR_INCREASE = 'rgba(139, 92, 246, 0.95)'; // violet (subió)
            const COLOR_DECREASE = 'rgba(34, 197, 94, 0.95)'; // green (bajó)
            const COLOR_SAME = 'rgba(2, 132, 199, 0.95)'; // blue (igual)
            const COLOR_DEFAULT_BORDER = 'rgba(139, 92, 246, 1)';

            for (let i = 0; i < data.length; i++) {
                const val = data[i];
                const prev = i > 0 ? data[i - 1] : val;
                if (val > prev) {
                    backgroundColors.push(COLOR_INCREASE);
                    borderColors.push(COLOR_DEFAULT_BORDER);
                } else if (val < prev) {
                    backgroundColors.push(COLOR_DECREASE);
                    borderColors.push('rgba(34, 197, 94, 1)');
                } else {
                    backgroundColors.push(COLOR_SAME);
                    borderColors.push('rgba(2, 132, 199, 1)');
                }
            }

            popup.classList.remove('hidden');
            lucide.createIcons();

            const ctx = document.getElementById('price-chart-canvas').getContext('2d');

            if (priceChartInstance) {
                priceChartInstance.destroy();
            }

            priceChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Precio',
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 1,
                        borderRadius: 6,
                        barPercentage: 0.9,
                        categoryPercentage: 0.85,
                        maxBarThickness: 48
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            // linear scale starting at half of the minimum price to preserve dynamics
                            ticks: {
                                color: '#e5e7eb',
                                callback: function (value) {
                                    // Short format: 30500 -> "30,5k"; 1500000 -> "1,5M"
                                    const abs = Math.abs(value);
                                    if (abs >= 1000000) {
                                        return (value / 1000000).toFixed(1).replace('.', ',') + 'M';
                                    } else if (abs >= 1000) {
                                        return (value / 1000).toFixed(1).replace('.', ',') + 'k';
                                    }
                                    return value.toString();
                                }
                            },
                            grid: { color: 'rgba(55, 65, 81, 0.5)' },
                            min: minChart
                        },
                        x: {
                            // show default tick text; plugin will only overdraw month labels (those containing '/') in bold
                            ticks: { color: '#e5e7eb' },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            callbacks: {
                                title: function (tooltipItems) {
                                    // Show weekday + short date as title (ej. Lunes 4/8)
                                    if (!tooltipItems || !tooltipItems.length) return '';
                                    const idx = tooltipItems[0].dataIndex;
                                    const point = historicalData[idx];
                                    if (!point) return tooltipItems[0].label || '';
                                    const d = new Date(point.date);
                                    const weekday = new Intl.DateTimeFormat('es-AR', { weekday: 'long' }).format(d);
                                    const shortDate = new Intl.DateTimeFormat('es-AR', { day: 'numeric', month: 'numeric' }).format(d);
                                    return `${weekday.charAt(0).toUpperCase()}${weekday.slice(1)} ${shortDate}`;
                                },
                                label: function (context) {
                                    const idx = context.dataIndex;
                                    const value = context.dataset.data[idx];
                                    return `Precio: $${formatShortNumber(value)}`;
                                },
                                afterLabel: function (context) {
                                    const idx = context.dataIndex;
                                    const point = historicalData[idx];
                                    if (!point) return '';
                                    const pointDate = new Date(point.date);
                                    const now = new Date();
                                    const msPerDay = 1000 * 60 * 60 * 24;
                                    const daysAgo = Math.floor((now - pointDate) / msPerDay);
                                    const pointPrice = point.value;

                                    // previous day's price (if exists in filled data)
                                    const prevPoint = idx > 0 ? historicalData[idx - 1] : null;
                                    const prevPrice = prevPoint ? prevPoint.value : null;

                                    // delta vs latest (today)
                                    const diffLatest = latestPrice !== null ? (latestPrice - pointPrice) : 0;
                                    const diffLatestSign = diffLatest > 0 ? '+' : (diffLatest < 0 ? '-' : '');
                                    const diffLatestFormatted = formatShortNumber(Math.abs(diffLatest));

                                    const lines = [`Hace: ${daysAgo} días`, `Δ vs hoy: ${diffLatestSign}$${diffLatestFormatted}`];

                                    // If the price changed vs previous day, also show whether it 'Subió' or 'Bajó' and the difference
                                    if (prevPrice !== null && prevPrice !== pointPrice) {
                                        const diffPrev = pointPrice - prevPrice;
                                        const diffPrevSign = diffPrev > 0 ? '+' : (diffPrev < 0 ? '-' : '');
                                        const diffPrevFormatted = formatShortNumber(Math.abs(diffPrev));
                                        const verb = diffPrev > 0 ? 'Subió' : 'Bajó';
                                        lines.push(`${verb}: ${diffPrevSign}$${diffPrevFormatted}`);
                                    }

                                    return lines;
                                }
                            }
                        }
                    }
                },
                // Per-instance plugin: draw bold x-axis labels for labels that include the month (contain '/')
                plugins: [{
                    id: 'boldMonthLabelsPlugin',
                    afterDraw: function (chart) {
                        try {
                            const ctx = chart.ctx;
                            const meta = chart.getDatasetMeta(0);
                            if (!meta || !meta.data || !chart.scales || !chart.scales.x) return;
                            const xScale = chart.scales.x;
                            ctx.save();
                            ctx.fillStyle = '#e5e7eb';
                            const baseFont = '12px Saira, Inter, sans-serif';
                            const boldFont = '700 12px Saira, Inter, sans-serif';
                            ctx.textAlign = 'center';
                            // y position slightly below the axis baseline
                            const y = xScale.bottom + 12;
                            meta.data.forEach((bar, i) => {
                                const label = chart.data.labels[i];
                                if (!label) return;
                                // Only overdraw labels that include '/' (those with month)
                                if (label.toString().includes('/')) {
                                    ctx.font = boldFont;
                                    ctx.fillText(label.toString(), bar.x, y);
                                }
                            });
                            ctx.restore();
                        } catch (e) {
                            // silently ignore plugin drawing errors
                        }
                    }
                }]
            });
            // Note: per-user request, on-canvas delta labels removed — deltas shown in tooltip now.
            // Keep a reference to the bar colors so toggle can reuse them
            try {
                priceChartInstance._barColors = { backgroundColors: backgroundColors, borderColors: borderColors };
                priceChartInstance._currentType = 'bar';
            } catch (e) {
                // ignore if Chart instance doesn't accept custom props
            }
        }

        function closePriceChartPopup() {
            const popup = document.getElementById('price-chart-popup');
            popup.classList.add('hidden');
            if (priceChartInstance) {
                priceChartInstance.destroy();
                priceChartInstance = null;
            }
        }

        function toggleChartType() {
            if (!priceChartInstance) return;
            const current = priceChartInstance._currentType || priceChartInstance.config.type;
            const target = current === 'bar' ? 'line' : 'bar';

            // Update config.type
            priceChartInstance.config.type = target;

            // Adjust dataset visual properties for line vs bar
            const ds = priceChartInstance.data.datasets[0];
            if (target === 'line') {
                // convert bar colors into line styling
                ds.backgroundColor = 'rgba(75,85,99,0.15)';
                ds.borderColor = priceChartInstance._barColors ? priceChartInstance._barColors.backgroundColors.map(c => c) : ds.borderColor || 'rgba(99,102,241,1)';
                ds.borderWidth = 2;
                ds.fill = false;
                ds.pointRadius = 4;
                ds.tension = 0.2;
            } else {
                // restore bar properties
                if (priceChartInstance._barColors) {
                    ds.backgroundColor = priceChartInstance._barColors.backgroundColors;
                    ds.borderColor = priceChartInstance._barColors.borderColors;
                }
                ds.borderWidth = 1;
                ds.borderRadius = 6;
                ds.barPercentage = 0.9;
                ds.categoryPercentage = 0.85;
                ds.maxBarThickness = 48;
                ds.fill = false;
                ds.pointRadius = 0;
                ds.tension = 0;
            }

            priceChartInstance._currentType = target;
            priceChartInstance.update();

            // Update toggle button icon
            const btnIcon = document.querySelector('#toggle-chart-type-btn .lucide-icon');
            if (btnIcon) {
                btnIcon.setAttribute('data-lucide', target === 'bar' ? 'bar-chart' : 'line-chart');
                lucide.createIcons({ nodes: [btnIcon] });
            }
        }

        // --- Filter Popup Logic ---
        function openFilterPopup() {
            document.getElementById('filter-popup').classList.remove('hidden');
            renderColorFilterOptions();
            lucide.createIcons();
        }

        function closeFilterPopup() {
            document.getElementById('filter-popup').classList.add('hidden');
        }

        function renderColorFilterOptions() {
            const container = document.getElementById('color-filter-options');
            const options = [
                { key: 'increased', label: 'Precio Subió', color: 'rgba(139, 92, 246, 0.3)' },
                { key: 'decreased', label: 'Precio Bajó', color: 'rgba(34, 197, 94, 0.3)' },
                { key: 'same', label: 'Precio Igual (Revisado)', color: 'rgba(2, 132, 199, 0.3)' },
                { key: 'default', label: 'Sin Cambios', color: 'transparent' }
            ];

            container.innerHTML = options.map(opt => `
            <label class="filter-checkbox-label">
                <input type="checkbox" onchange="toggleColorFilter('${opt.key}')" ${filterState[opt.key] ? 'checked' : ''}>
                <span class="color-swatch" style="background-color: ${opt.color};"></span>
                <span class="text-gray-300">${opt.label}</span>
            </label>
        `).join('');
        }

        function toggleColorFilter(key) {
            filterState[key] = !filterState[key];
            applyColorFilter();
        }

        function applyColorFilter() {
            document.querySelectorAll('tr[id^="row-"]').forEach(row => {
                const status = row.dataset.priceStatus || 'default';
                row.style.display = filterState[status] ? '' : 'none';
            });

            document.querySelectorAll('.category-table-container').forEach(container => {
                const visibleProductRows = container.querySelectorAll('tbody tr[id^="row-"]:not([style*="display: none"])');
                container.style.display = visibleProductRows.length === 0 ? 'none' : 'block';
            });
        }

        function colorAllRowsByPriceChange() {
            document.querySelectorAll('tr[id^="row-"]').forEach(row => {
                const [_, categoryKey, indexStr] = row.id.split('-');
                const index = parseInt(indexStr, 10);
                const product = dataMap[categoryKey][index];

                if (product && product.prices && product.prices.length > 1) {
                    const newPrice = product.prices[0].value;
                    const oldPrice = product.prices[1].value;
                    applyPriceChangeVisuals(row, oldPrice, newPrice);
                } else {
                    row.style.backgroundColor = '';
                    row.dataset.priceStatus = 'default';
                    const priceWrapper = row.querySelector('.price-wrapper');
                    if (priceWrapper) {
                        const existingIndicator = priceWrapper.querySelector('.previous-price-indicator');
                        if (existingIndicator) existingIndicator.remove();
                    }
                }
            });
            applyColorFilter();
            closeFilterPopup();
            showToast('Coloreado de filas aplicado.', 'success');
        }

        // --- Price Check Loop Logic (REFACTORED) ---

        function initializePriceCheckQueue() {
            priceCheckQueue = [];
            CATEGORY_NAV_LIST.forEach(category => {
                const categoryKey = category.key;
                if (!categoryKey.includes('Options')) return;

                (dataMap[categoryKey] || []).forEach((product) => {
                    // Include all products that have a link (no visibility check)
                    if (product && product.link) {
                        priceCheckQueue.push({ categoryKey, productId: product.id });
                    }
                });
            });
            updatePriceCheckQueueCount();
        }

        function startSinglePriceCheckAndContinue(categoryKey, index) {
            const product = dataMap[categoryKey][index];
            if (!product) return;

            const startIndex = priceCheckQueue.findIndex(item => item.productId === product.id && item.categoryKey === categoryKey);

            if (startIndex === -1) {
                showToast('Este producto no puede iniciar un chequeo en lote (puede no ser visible o no tener link).', 'error');
                openPriceCheckPopup(categoryKey, index, false); // Open for single check only
                return;
            }

            currentQueueIndex = startIndex;
            isLoopRunning = true;

            processNextInQueue();
        }

        function togglePriceCheckLoop() {
            if (isLoopRunning) {
                pausePriceCheckLoop();
            } else {
                startPriceCheckLoop();
            }
        }

        function startPriceCheckLoop() {
            isLoopRunning = true;
            updateLoopButtonUI(true);

            currentQueueIndex = parseInt(sessionStorage.getItem('priceCheckQueueIndex') || '0', 10);

            if (currentQueueIndex >= priceCheckQueue.length) {
                currentQueueIndex = 0;
                sessionStorage.setItem('priceCheckQueueIndex', '0');
            }

            if (priceCheckQueue.length === 0) {
                showToast('No hay productos para chequear (no hay links disponibles).', 'error');
                resetPriceCheckLoop();
                return;
            }

            processNextInQueue();
        }

        function pausePriceCheckLoop() {
            isLoopRunning = false;
            sessionStorage.setItem('priceCheckQueueIndex', currentQueueIndex);
            updateLoopButtonUI(false);
            showToast('Chequeo en lote pausado.');
        }

        function resetPriceCheckLoop() {
            isLoopRunning = false;
            priceCheckQueue = [];
            currentQueueIndex = 0;
            sessionStorage.removeItem('priceCheckQueueIndex');
            initializePriceCheckQueue(); // Rebuild the queue on reset
            updateLoopButtonUI(false);
            updatePriceCheckQueueCount();
        }

        function updatePriceCheckQueueCount() {
            const el = document.getElementById('price-check-queue-count');
            if (!el) return;
            const total = (priceCheckQueue && priceCheckQueue.length) ? priceCheckQueue.length : 0;
            const idx = Number.isInteger(currentQueueIndex) ? currentQueueIndex : 0;

            // If the loop is running, show how many remain (including current index position)
            if (isLoopRunning) {
                const remaining = Math.max(0, total - idx);
                el.textContent = String(remaining);
                return;
            }

            // If loop is not running but we've progressed (saved index > 0 and less than total),
            // show the remaining items instead of the full total so the user sees progress after pause/cancel.
            if (idx > 0 && idx < total) {
                el.textContent = String(Math.max(0, total - idx));
                return;
            }

            // Default: show total count
            el.textContent = String(total);
        }

        function processNextInQueue() {
            if (!isLoopRunning) return;

            if (currentQueueIndex >= priceCheckQueue.length) {
                showToast('¡Chequeo en lote completado!', 'success');
                resetPriceCheckLoop();
                return;
            }

            const twoHoursInMs = 2 * 60 * 60 * 1000;
            const twoHoursAgo = new Date(Date.now() - twoHoursInMs);

            let itemToCheck = null;
            while (currentQueueIndex < priceCheckQueue.length) {
                const potentialItem = priceCheckQueue[currentQueueIndex];
                if (!potentialItem) { currentQueueIndex++; continue; }

                // Resolve the current index of the product dynamically by productId + categoryKey
                const arr = dataMap[potentialItem.categoryKey] || [];
                const resolvedIndex = arr.findIndex(p => p && p.id === potentialItem.productId);
                const product = resolvedIndex > -1 ? arr[resolvedIndex] : null;

                // If product missing (removed) skip
                if (!product) {
                    currentQueueIndex++;
                    continue;
                }

                // Parse lastUpd safely; invalid dates => eligible
                let eligible = true;
                if (product.lastUpd) {
                    try {
                        const lastDate = new Date(product.lastUpd);
                        if (!isNaN(lastDate.getTime())) {
                            eligible = lastDate < twoHoursAgo;
                        } else {
                            eligible = true;
                        }
                    } catch (e) {
                        eligible = true;
                    }
                } else {
                    eligible = true;
                }

                if (eligible) {
                    // Attach resolved index so popup opens at the correct row
                    itemToCheck = { categoryKey: potentialItem.categoryKey, productId: potentialItem.productId, index: resolvedIndex };
                    break;
                }

                currentQueueIndex++;
            }

            sessionStorage.setItem('priceCheckQueueIndex', currentQueueIndex);
            updateLoopButtonUI(true, `(${currentQueueIndex}/${priceCheckQueue.length})`);

            if (itemToCheck) {
                scrollToComponentRow(itemToCheck.categoryKey, itemToCheck.index);
                setTimeout(() => {
                    openPriceCheckPopup(itemToCheck.categoryKey, itemToCheck.index, true);
                }, 200);
            } else {
                showToast('¡Chequeo en lote completado! (No hay más productos que necesiten revisión)', 'success');
                resetPriceCheckLoop();
            }
        }

        function updateLoopButtonUI(isRunning, progressText = '') {
            const btn = document.getElementById('price-check-loop-btn');
            const btnText = document.getElementById('price-check-loop-btn-text');
            const icon = btn.querySelector('.lucide-icon');

            if (isRunning) {
                btnText.textContent = `Pausar Chequeo ${progressText}`;
                icon.setAttribute('data-lucide', 'pause-circle');
            } else {
                const savedIndex = parseInt(sessionStorage.getItem('priceCheckQueueIndex') || '0', 10);
                if (savedIndex > 0 && savedIndex < priceCheckQueue.length) {
                    btnText.textContent = `Continuar Chequeo (${savedIndex}/${priceCheckQueue.length})`;
                } else {
                    btnText.textContent = 'Chequeo en Lote';
                }
                icon.setAttribute('data-lucide', 'play-circle');
            }
            lucide.createIcons({ nodes: [icon] });
            // Update visible count (total or remaining) whenever loop UI changes
            updatePriceCheckQueueCount();
        }

        // --- Code Export ---

        function generateCode() {
            const exportData = JSON.parse(JSON.stringify(dataMap));
            for (const mapKey in exportData) {
                if (mapKey.includes('Options')) {
                    exportData[mapKey].forEach(p => {
                        p.price = p.prices && p.prices.length > 0 ? p.prices[0].value : 0;
                        delete p.prices;
                        delete p.linksAlt;
                    });
                }
            }

            const code = JSON.stringify(exportData, null, 2);
            document.getElementById('output-code').value = code;
            return code;
        }

        function copyCode() {
            const outputTextArea = document.getElementById('output-code');
            generateCode();
            outputTextArea.select();
            document.execCommand('copy');
            showToast('¡Código Actual copiado al portapapeles!');
        }

        function generateHistoryCode() {
            const exportData = JSON.parse(JSON.stringify(dataMap));
            for (const mapKey in exportData) {
                if (mapKey.includes('Options')) {
                    exportData[mapKey].forEach(p => {
                        delete p.price;
                        delete p.lastUpd;
                    });
                }
            }

            const code = JSON.stringify(exportData, null, 2);
            document.getElementById('output-code').value = code;
            return code;
        }

        function copyHistoryCode() {
            const outputTextArea = document.getElementById('output-code');
            generateHistoryCode();
            outputTextArea.select();
            document.execCommand('copy');
            showToast('¡Historial de precios copiado al portapapeles!');
        }


        function resetSessionAndReload() {
            sessionStorage.removeItem('productAdminData');
            sessionStorage.removeItem('priceCheckQueueIndex');
            location.reload();
        }

        async function reloadDataFromJson() {
            try {
                const response = await fetch('productsH.json?cache_bust=' + new Date().getTime());
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const dataToLoad = await response.json();

                for (const key in dataMap) {
                    if (dataToLoad.hasOwnProperty(key)) {
                        dataMap[key] = dataToLoad[key];
                    } else {
                        dataMap[key] = [];
                    }
                }

                sanitizeAndAssignDefaults();
                updateAllBaseTotals();
                renderBasesSection();
                renderBundlesSection();
                renderOverviewTables();
                saveDataToSessionStorage();
                initializePriceCheckQueue();
                showToast('Datos recargados desde productsH.json');

            } catch (error) {
                console.error("Error reloading from JSON:", error);
                showToast('Error al recargar el archivo productsH.json.', 'error');
            }
        }

        // --- Page Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            document.addEventListener('click', (event) => {
                if (openLinkManagerId) {
                    const manager = document.getElementById(openLinkManagerId);
                    // The event target might not be in the DOM anymore if the table was re-rendered.
                    // A simple check to see if the manager exists is enough.
                    if (manager && !manager.contains(event.target) && !event.target.closest(`button[onclick*="toggleLinkManager"]`)) {
                        manager.classList.add('hidden');
                        openLinkManagerId = null;
                    }
                }
            });

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    if (!document.getElementById('price-check-popup').classList.contains('hidden')) {
                        closePriceCheckPopup();
                    }
                    if (!document.getElementById('price-chart-popup').classList.contains('hidden')) {
                        closePriceChartPopup();
                    }
                    if (!document.getElementById('filter-popup').classList.contains('hidden')) {
                        closeFilterPopup();
                    }
                    if (openLinkManagerId) {
                        const manager = document.getElementById(openLinkManagerId);
                        if (manager) manager.classList.add('hidden');
                        openLinkManagerId = null;
                    }
                    if (!document.getElementById('gemini-analysis-popup').classList.contains('hidden')) {
                        closeGeminiPopup();
                    }
                }
            });

            let dataToLoad = null;
            const storedData = loadDataFromSessionStorage();

            if (storedData) {
                dataToLoad = storedData;
                showToast('¡Datos restaurados de la sesión anterior!', 'success');
            } else {
                try {
                    const response = await fetch('productsH.json?cache_bust=' + new Date().getTime());
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    dataToLoad = await response.json();
                } catch (error) {
                    console.error('Error loading productsH.json:', error);
                    showToast('No se pudo cargar productsH.json. Se iniciará con datos vacíos.', 'error');
                }
            }

            if (dataToLoad) {
                for (const key in dataMap) {
                    if (dataToLoad.hasOwnProperty(key)) {
                        dataMap[key] = dataToLoad[key];
                    }
                }
            }

            sanitizeAndAssignDefaults();
            updateAllBaseTotals();
            renderCategoryNavbar();
            renderBasesSection();
            renderBundlesSection();
            renderOverviewTables();
            saveDataToSessionStorage();
            lucide.createIcons();

            initializePriceCheckQueue();
            const savedIndex = parseInt(sessionStorage.getItem('priceCheckQueueIndex') || '0', 10);
            if (savedIndex > 0 && savedIndex < priceCheckQueue.length) {
                currentQueueIndex = savedIndex;
                updateLoopButtonUI(false);
            }

            window.addEventListener('resize', updateNavbarSpacer);

            document.querySelectorAll('.accordion-header').forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const icon = header.querySelector('.lucide-icon');
                    content.classList.toggle('hidden');
                    icon.classList.toggle('rotate-180');
                });
            });
        });

    </script>
</body>

</html>